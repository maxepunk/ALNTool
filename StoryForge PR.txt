**Revised & Consolidated Project Request Document: StoryForge - Immersive Narrative Design Hub**

**Document Version:** 3.6.0
**Date:** May 26, 2025
**Document Purpose:** This document provides the comprehensive and unified specification for the StoryForge tool. It reflects the outcomes of an architectural and codebase review (May 2025), incorporates a definitive understanding of the existing "About Last Night" Notion workspace structure, details the current and planned data flow for the Relationship Mapper, includes detailed User Personas and Use Cases, and contains the current detailed Action Plan for ongoing development. It is intended to serve as the gold-standard reference.

**1. Project Background: The "About Last Night" Experience**
*   **Game:** "About Last Night... an Immersive Crime Thriller" (Internal Codename: "Recovery State")
*   **Overview:** A 90-minute, in-person immersive experience for 5-35 players in a near-future Silicon Valley setting. It combines escape room puzzles, role-play, social deduction, and strategic trading.
*   **Premise:** Players awaken in a warehouse post-party, memories fragmented, with CEO Marcus Blackwood dead.
    *   **Act 1: Murder Mystery:** Players investigate Marcus's death, recover "elements" (including physical/digital items representing memories), and build theories.
    *   **Act 2: Memory Trading & Deeper Conspiracy:** Discovery of a "memory reader" (RFID-based) reveals certain elements (specifically those designated as "memories") as tradable commodities. Marcus's death is revealed as self-inflicted due to memory-altering drug experiments. A countdown begins as memories risk irreversible corruption.
*   **Player Choices/Endings:** Cooperate with "The Detective," sell memories to the "Black Market," or work to recover personal memories.
*   **Central Mechanics:** Element Recovery (including Memory recovery), Puzzle Solving, Role-Playing & Social Deduction, Strategic Trading (Act 2).

**2. Project Overview & Goals (StoryForge Tool)**
*   **Project Name:** StoryForge
*   **Tool Goal:** To develop a custom web-based front-end design tool that uses the existing "About Last Night" Notion workspace (as defined in Section 4) as its backend. StoryForge will provide a visually intuitive, interconnected, and role-optimized environment for designing, managing, and iterating on the immersive narrative experience.
*   **Primary Objectives:**
    *   **Visualize Connections:** Enable easy understanding of relationships between Characters, Timeline Events, Puzzles, and Elements (including specialized Memory-type Elements).
    *   **Streamline Workflows:** Offer dedicated views and tools tailored for different team roles (Narrative Designer, Writer, Puzzle Designer, Asset Manager).
    *   **Centralize & Enhance Data Access:** Provide a more structured and interactive way to access and modify data stored in Notion databases.
    *   **Facilitate Iteration & Scaling:** Support ongoing design changes, ensure narrative consistency, and manage the complexity of a growing narrative.
    *   **Support Design Process:** Address interdependencies, timeline management, act structure, physical prop management, and playtesting.

**3. Core Technology Stack**
*   **Backend Data Store:** **Existing Notion Workspace** (via Notion API). *This is a critical constraint. The structure defined in Section 4 is the target.*
*   **Frontend Framework:** React (as implemented).
*   **Visualization Libraries:** `@xyflow/react` (React Flow) is the primary visualization library used.
*   **State Management:** React Query (as implemented for API service layer) and Zustand. Zustand is currently used for client-side UI state (e.g., within the Relationship Mapper); the complexity of this client-side state may be reduced with the focused rebuild of the Relationship Mapper, which simplifies its UI controls and layout options.
*   **Styling:** Material UI with a dark theme (as implemented).
*   **Backend-for-Frontend (BFF) / Middleware:** Node.js with Express.js (as implemented). This BFF handles Notion API interactions, caching (using `node-cache`), complex data transformations (including generation of rich `graphData` for visualization as per Section 4.E), and secure API key management.

**4. Notion Backend Structure (Definitive Gold Standard)**

StoryForge **must** read from and write to the Notion workspace structured with the following 4 primary databases. Property names and types provided below are based on the May 2025 codebase review and successful Phase 1 integration.

**Important Note on "Memory-Specific" Fields within the Elements Database:**
The `Elements` database serves as a general store for all items, including those that function narratively as "Memories." For a minimal set of memory-specific attributes not covered by existing dedicated Notion properties, a strategy of embedding structured data within the `Description/Text` field will be used.
*   **Strategy for Handling (Implemented):**
    1.  **Data Entry Template:** Memory-specific attributes are entered on their own line within the `Description/Text` field of an Element, prefixed with `SF_`. Currently supported attributes are:
        *   `SF_RFID: [value]` (e.g., `SF_RFID: 12345`)
        *   `SF_ValueRating: [1-5]` (e.g., `SF_ValueRating: 3`)
        *   `SF_MemoryType: [Personal|Business|Technical]` (e.g., `SF_MemoryType: Business`)
    2.  **BFF Responsibility (Read):** For Elements identified as memories (e.g., via `Basic Type` like "Memory Token Video", "Corrupted Memory RFID"), the BFF (`storyforge/backend/src/utils/notionPropertyMapper.js` in `mapElementWithNames`) parses the `Description/Text` content to extract these `SF_` prefixed attributes.
    3.  **Parsed Data Storage:** These parsed values (`parsed_sf_rfid`, `sf_value_rating`, `sf_memory_type`) are added to the `properties` object of the mapped element data returned by the API (e.g., `element.properties.parsed_sf_rfid`).
    4.  **Frontend Display:** The frontend (`storyforge/frontend/src/pages/ElementDetail.jsx`, `storyforge/frontend/src/pages/MemoryEconomyPage.jsx`) uses these parsed properties for display and calculations.
    5.  **Future - Editing (Write Responsibility):** (Out of scope for current implementation) When/if editing these embedded attributes is implemented in StoryForge, the tool will need to update the structured information within the `Description/Text` field carefully.
    6.  **Future - Adding New Notion Properties (Last Resort):** If this embedded attribute approach proves insufficient or unmanageable, adding new explicit properties to the Notion `Elements` database will be considered.

**(A) Characters Database**
*   **Notion DatabaseID:** `18c2f33d583f8060a6abde32ff06bca2`
*   **Properties:** (Verified against codebase and sample data)
    *   `Name` (Title - Primary Key)
    *   `Type` (Select: "Player", "NPC")
    *   `Tier` (Select: "Core", "Secondary", "Tertiary")
    *   `Character Logline` (Text)
    *   `Overview & Key Relationships` (Rich Text)
    *   `Emotion towards CEO & others` (Text)
    *   `Primary Action` (Text - Primary goal at the party)
    *   `Events` (Relation to `Timeline` DB - `Timeline.Description`)
    *   `Character Puzzles` (Relation to `Puzzles` DB - `Puzzles.Puzzle`)
    *   `Owned Elements` (Relation to `Elements` DB - `Elements.Name`)
    *   `Associated Elements` (Relation to `Elements` DB - `Elements.Name`)
    *   `Connections` (Number)
    *   *(Content from individual Character MD files is represented by an `Owned Element` of `Basic Type`: "Character Sheet". The `Description/Text` of that Element contains the sheet content.)*

**(B) Timeline Database (Events)**
*   **Notion DatabaseID:** `1b52f33d583f80deae5ad20020c120dd`
*   **Properties:** (Verified)
    *   `Description` (Title - Primary Key, e.g., Event title)
    *   `Date` (Date)
    *   `Characters Involved` (Relation to `Characters` DB - `Characters.Name`)
    *   `Memory/Evidence` (Relation to `Elements` DB - `Elements.Name`)
    *   `mem type` (Text/Select - e.g., "Prop", "Set Dressing", "Memory Token Video")
    *   `Notes` (Rich Text)

**(C) Puzzles Database**
*   **Notion DatabaseID:** `1b62f33d583f80cc87cfd7d6c4b0b265`
*   **Properties:** (Verified)
    *   `Puzzle` (Title - Primary Key, e.g., Puzzle name)
    *   `Owner` (Relation to `Characters` DB - `Characters.Name`)
    *   `Locked Item` (Relation to `Elements` DB - `Elements.Name`)
    *   `Puzzle Elements` (Relation to `Elements` DB - `Elements.Name`, i.e., elements required for the puzzle)
    *   `Rewards` (Relation to `Elements` DB - `Elements.Name`, i.e., elements rewarded by the puzzle)
    *   `Story Reveals` (Text or Relation to `Timeline` DB - `Timeline.Description`)
    *   `Timing` (Select, e.g., "Act 1", "Act 2")
    *   `Parent item` (Relation to self - `Puzzles.Puzzle`, for sub-puzzles)
    *   `Sub-Puzzles` (Relation to self, multiple - `Puzzles.Puzzle`, for parent puzzles listing sub-puzzles)
    *   `Asset Link` (URL, e.g., Canva links)
    *   `Description/Solution` (Rich Text)
    *   `Narrative Threads` (Multi-select Text or individual Text properties if preferred for Notion filtering)

**(D) Elements Database**
*   **Notion DatabaseID:** `18c2f33d583f802091bcd84c7dd94306`
*   **Properties:** (Verified)
    *   `Name` (Title - Primary Key)
    *   `Owner` (Relation to `Characters` DB - `Characters.Name`)
    *   `Basic Type` (Select - e.g., "Prop", "Set Dressing", "Memory Token Video", "Memory Token Audio", "Memory Token Physical", "Corrupted Memory RFID", "Character Sheet", "Document", "Digital File", "Clue", "Container")
    *   `Description/Text` (Rich Text - Sourced from MD bodies. For memory-type Elements, this field will also contain structured data for minimal memory-specific attributes like `SF_RFID: [value]` as defined in the strategy above. The broader list of attributes such as `Memory ID`, `Memory Title`, `Memory Type (Narrative)`, `Content (for text memories)`, `Corruption Status`, `Value Indicator`, `Puzzle Integration Type`, `Puzzle Notes` are for future consideration if the minimal approach is insufficient.)
    *   `Container` (Relation to self - `Elements.Name`, i.e., this element is *inside* another element)
    *   `Contents` (Relation to self, multiple - `Elements.Name`, i.e., this element *is* a container and lists items inside)
    *   `Container Puzzle` (Relation to `Puzzles` DB - `Puzzles.Puzzle`)
    *   `Required For (Puzzle)` (Relation to `Puzzles` DB - `Puzzles.Puzzle`)
    *   `Rewarded by (Puzzle)` (Relation to `Puzzles` DB - `Puzzles.Puzzle`)
    *   `Timeline Event` (Relation to `Timeline` DB - `Timeline.Description`)
    *   `Associated Characters` (Relation to `Characters` DB - `Characters.Name`)
    *   `Narrative Threads` (Multi-select Text or individual Text properties)
    *   `First Available` (Select, e.g., "Act 0", "Act 1", "Act 2")
    *   `Status` (Select - e.g., "Ready for Playtest", "Done", "In development", "Idea/Placeholder", "Source Prop/print", "To Design", "To Build", "Needs Repair")
    *   `Files & media` (Files & Media - For images, audio files, video files directly uploaded to Notion)
    *   `Content Link` (URL - For links to external files like Canva, Google Docs, or video/audio hosting if not using `Files & media`)
    *   `Production/Puzzle Notes` (Text)
    *   *(`Container?` (Boolean) - Consider for formal support based on sample CSV)*
    *   *(`Puzzle Chain` (URL/Relation) - Consider for formal support based on sample CSV)*

**(E) BFF `graphData` Object Specification (for Relationship Mapper)**
(Specification remains current and accurate based on code review of `notionController.js` helpers `_createGraphNodeInternal` and `_createGraphEdgeInternal`. The following fields within the `graphData` object are particularly critical for the Relationship Mapper's focused hierarchical layout strategy:
*   `nodes[n].id`, `nodes[n].name`, `nodes[n].type`, and `nodes[n].properties`: Essential for node rendering, labeling, and differentiation.
*   `edges[e].source`, `edges[e].target`, `edges[e].label`: Define basic connectivity and on-edge textual labels.
*   `edges[e].data.shortLabel`: Critically important, as the frontend logic in `useGraphTransform.js` relies on specific `shortLabel` values (e.g., "Contains," "Required For," "Rewards") to programmatically assign `parentId` attributes to nodes. This `parentId` assignment is the foundation for creating visual groupings using Dagre compound nodes and React Flow's parent rendering.
*   `edges[e].data.contextualLabel`: Used for detailed tooltips on edges.
The frontend's ability to effectively group related nodes (e.g., container contents, puzzle inputs/outputs) is directly dependent on the consistency and accuracy of these labels, especially `shortLabel`, originating from the BFF.
**Note (May 21, 2025):** The `storyforge/backend/src/controllers/notionController.js` (SHA `37e3b9ab1cabccbe0873fc0986c2cf01190539d0`) was updated to ensure the `getCharacterGraph` function explicitly generates "Contains" edges (with `shortLabel: "Contains"`) in the `graphData` for elements that are direct contents of 1st-degree container Elements owned by or associated with the central character. This addresses a previous gap where such containment relationships were not explicitly available for grouping on Character-centric maps.)
'''json
{
  "center": { /* Fully mapped central entity object, matching structure of a node below */ },
  "nodes": [
    {
      "id": "string_entity_id",
      "name": "string_display_name",
      "type": "string_entity_type",
      "fullDescription": "string_long_form_description_for_tooltip",
      "descriptionSnippet": "string_short_snippet_for_tooltip",
      // Type-specific enriched properties (from `_createGraphNodeInternal` in BFF):
      // For Character:
      "tier": "string_tier_value",
      "role": "string_player_or_npc",
      "primaryActionSnippet": "string_snippet_of_primary_action",
      // For Puzzle:
      "timing": "string_act_timing",
      "statusSummary": "string_e_g_requires_x_rewards_y",
      "storyRevealSnippet": "string_snippet_of_story_reveals",
      "ownerName": "string_character_name_if_any",
      "ownerId": "string_character_id_if_any",
      // For Element:
      "basicType": "string_element_basic_type",
      "status": "string_production_status",
      "flowSummary": "string_e_g_owner_x_required_for_y_rewarded_by_z",
      // For Timeline:
      "dateString": "string_formatted_date",
      "participantSummary": "string_e_g_involves_x_chars_y_elements",
      "notesSnippet": "string_snippet_of_notes"
    }
  ],
  "edges": [
    {
      "source": "string_source_node_id",
      "target": "string_target_node_id",
      "label": "string_simple_relationship_label",
      "data": {
        "sourceNodeName": "string_source_node_display_name",
        "sourceNodeType": "string_source_node_type",
        "targetNodeName": "string_target_node_display_name",
        "targetNodeType": "string_target_node_type",
        "contextualLabel": "string_detailed_human_readable_label_for_tooltips",
        "shortLabel": "string_concise_label_for_on_path_display_and_grouping_logic"
      }
    }
  ]
}
'''

**5. Feature Breakdown & Development Phases**

All feature development, phasing, and detailed tasks are now managed under the **"Revised Action Plan: StoryForge Refinement & Advancement"** detailed in Section 9 of this document. Old milestone lists or feature breakdowns in previous versions of this PRD are superseded by Section 9.

**Key Development Phases Summary (Detailed in Section 9):**
*   **Phase 1: Codebase Hygiene, Documentation Synchronization & Critical Mapper UX Foundation (COMPLETED)** - Focused on PRD accuracy, code cleanup, and establishing a stable, usable Relationship Mapper with Dagre compound node layout (`rankdir: 'LR'`), enhanced node tooltips, and verified edge labeling.
*   **Phase 2: Advanced Mapper Enhancements, Minimal Memory Attribute Implementation, and UI/UX Polish (COMPLETED)** - Implemented advanced filtering in the mapper (Act, Theme, Memory Set), backend parsing for minimal memory attributes (RFID, Value Rating, Memory Type), refined mapper visuals, standardized detail page layouts, and added server-side filtering for `actFocus` (Timeline) and memory types (Elements).
*   **Phase 3: Advanced Design Views - Puzzle Flow, Narrative Threads, Memory Economy (COMPLETED)** - Introduced dedicated views for analyzing puzzle dependencies, tracking narrative threads across entities, and assessing the game's memory economy.
*   **Phase 4: Editing Capabilities, Further Refinements & Advanced Features (PENDING)** - Focus on enabling direct data modification in Notion via StoryForge, plus other advanced features.

**6. User Personas, Workflows, Relationship Mapper Use Cases & UX Principles**

This section details the primary users of StoryForge, their core tasks related to game design and development, how the Relationship Mapper views for each entity type are intended to support their workflows, and the UX principles guiding graph clarity. Understanding these user-centric scenarios is crucial for refining existing features and guiding future development.

**A. Primary User Personas / Roles:**

*   **P1: Narrative Designer (Lead Story Architect)**
    *   **Responsibilities:** Oversees the overall story arc, plot development, character motivations and arcs, thematic consistency, and narrative coherence across all game components (puzzles, elements, events). Ensures the player experience aligns with the intended narrative journey.
    *   **Core Tasks in StoryForge:**
        *   Reviewing and validating connections between characters, events, puzzles, and critical story elements.
        *   Identifying plot holes or inconsistencies in the narrative web.
        *   Tracking how key narrative threads (e.g., "CEO's Corruption," "Memory Drug Side Effects") propagate through various game components.
        *   Visualizing character relationship networks and their evolution.
        *   Ensuring puzzle solutions and element discoveries align with story progression.
*   **P2: Writer (Content Creator)**
    *   **Responsibilities:** Focuses on dialogue, scripts, in-game text (e.g., item descriptions, documents), character voice, and detailed descriptive content for elements, events, and locations.
    *   **Core Tasks in StoryForge:**
        *   Accessing detailed information about characters, elements, and events to ensure their writing is contextually accurate.
        *   Understanding the relationships an element has to write compelling descriptions or associated text.
        *   Reviewing how their written content (e.g., a clue found on an element) connects to puzzles or character knowledge.
*   **P3: Puzzle Designer (Mechanics & Flow Engineer)**
    *   **Responsibilities:** Designs, implements, and tests puzzles. Manages puzzle dependencies (what elements are required, what elements/information are rewarded), solvability, difficulty, and thematic integration with the narrative.
    *   **Core Tasks in StoryForge:**
        *   Visualizing the flow of a puzzle chain: inputs (required elements/info), internal steps/sub-puzzles, and outputs (reward elements/info, story reveals).
        *   Identifying all elements linked to a specific puzzle (required, rewarded, or locked by it).
        *   Ensuring puzzles don't create narrative dead-ends or require unobtainable items.
        *   Checking if a puzzle's reward correctly unlocks the next intended step in the story or another puzzle.
*   **P4: Asset Manager (Element & Prop Logistics)**
    *   **Responsibilities:** Tracks all physical and digital game elements (props, clues, media files, documents), their current status (e.g., "To Build," "Ready for Playtest"), location, and connections to other game components (characters, puzzles, events).
    *   **Core Tasks in StoryForge:**
        *   Quickly identifying all information about a specific element: its description, what puzzles it's used in, who owns it, what event it's related to.
        *   Understanding the "blast radius" of an element – if this element is changed or removed, what other parts of the game are affected?
        *   Managing container relationships (what's inside what).
        *   Tracking the status and availability of elements needed for playtesting specific scenes or puzzles.

**B. Entity-Specific Map Use Cases & Workflows (for Relationship Mapper):**

*   **B.1. Character Map (Viewing from a Character's Detail Page):**
    *   **Narrative Designer:** "How does this Character connect to the main plot points (Timeline Events)? What Puzzles are they crucial for? What key Elements do they own or are associated with that drive their story?"
    *   **Writer:** "What are this Character's key relationships (to other Characters, critical Elements, or Events) that I need to reflect in their dialogue or backstory?"
    *   **Use Case Example:** Viewing Alex Reeves' map to see direct links to "CEO's Office Confrontation" (Timeline Event), "Personal Safe" (Puzzle), and "Encrypted Hard Drive" (Owned Element).

*   **B.2. Element Map (Viewing from an Element's Detail Page):**
    *   **Asset Manager:** "Where is this Element used? Is it a reward for a Puzzle? Required for another? Who owns it? Is it evidence in a Timeline Event?"
    *   **Puzzle Designer:** "If this Clue (Element) is found, what Puzzles does it help solve? If it's a reward from Puzzle A, is it correctly linked as a requirement for Puzzle B?"
    *   **Narrative Designer:** "How does this specific Element (e.g., a 'Memory Token') connect to the larger narrative? Which Characters interact with it? Which Events does it illuminate?"
    *   **Use Case Example:** Viewing the "CEO's Diary" (Element) map to see it's a reward from the "Desk Drawer Lockbox" (Puzzle), is owned by "Marcus Blackwood" (Character), and contains clues related to the "Warehouse Party Setup" (Timeline Event).

*   **B.3. Puzzle Map (Viewing from a Puzzle's Detail Page):**
    *   **Puzzle Designer:** "What Elements are needed to solve this Puzzle? What Elements or information does it reward? Are there any sub-puzzles or is it part of a larger chain? Which Character is intended to solve or own this puzzle?"
    *   **Narrative Designer:** "Does this Puzzle appropriately gate a key Story Reveal or an important Element? Is its timing correct within the Act structure?"
    *   **Use Case Example:** Viewing the "Decrypt RFID Data" (Puzzle) map to see it requires "Corrupted Memory RFID" (Element) and "RFID Reader" (Element), and rewards "Decrypted CEO's Message" (Element).

*   **B.4. Timeline Event Map (Viewing from an Event's Detail Page):**
    *   **Narrative Designer:** "Which Characters were involved in this Event? What key Elements (memories, evidence) are associated with it? Does this Event logically connect to preceding or succeeding Events?"
    *   **Writer:** "Who was present at this Event and what significant items were there, to ensure my scene descriptions or character recollections are accurate?"
    *   **Use Case Example:** Viewing the "Security Breach" (Timeline Event) map to see "Victoria Kingsley" (Character) and "Maintenance Crew" (Character group) were involved, and "Security Footage VHS" (Element) is key evidence.

**C. Implications for Dashboard Design (Future Consideration):**

While the dashboard is currently a placeholder, understanding these personas and workflows will be vital when designing it. The dashboard should ideally provide:
*   Quick access to recently viewed/edited items per user.
*   Overviews relevant to each role (e.g., Narrative Designer might see a list of unresolved plot threads or unlinked critical elements; Puzzle Designer might see puzzles with missing required elements).
*   Global search functionality.
*   Notifications or alerts for items needing attention (e.g., an Element marked "To Build" that's required for an upcoming playtest).

**D. UX Principles for Graph Clarity in Relationship Mapper (Revised for Focused Dagre/Compound Node Strategy):**

To achieve the overarching goal of a Relationship Mapper that "tells a story" and is intuitively understandable, especially with the adoption of a focused Dagre-based compound node layout strategy, we will adhere to the following UX principles:

*   **1. Prioritize Hierarchical Grouping for Meaning:**
    *   **Principle:** The most critical aspect for clarity is the explicit visual grouping of semantically related hierarchical units.
    *   **Implementation:** This is actively implemented via Dagre's compound node feature.
        *   **Compound Nodes:** Dagre's compound node feature, activated via `g.setParent()` based on frontend `data.parentId` assignment, is the primary mechanism. This visually encapsulates:
            *   Elements `Contains`-ed within a parent Element (container).
            *   Elements `Required For` or `Rewards`-ed by a Puzzle.
        *   **Visual Distinction of Groups:** Parent/group nodes rendered by React Flow (using the `parentNode` attribute) have distinct styling (e.g., subtle background, border) to clearly delineate their boundaries and visually separate their internal content from the wider graph.
    *   **Benefit:** Users will immediately see these "sub-systems" or collections (e.g., "everything in this backpack," "all elements directly involved in this puzzle") as coherent visual units, drastically reducing the need to trace multiple edges to infer these groupings.

*   **2. Streamlined Layout for Reduced Cognitive Load:**
    *   **Principle:** Avoid overwhelming the user with excessive options or an overly dense "hairball" of lines and nodes. The layout should be clean, and connections easy to follow.
    *   **Implementation:** The single, highly refined Dagre-based hierarchical layout strategy is successfully in place.
        *   **Single Core Layout Strategy:** Focus on a highly refined Dagre-based hierarchical layout. Remove alternative, less effective layout options (Radial, Force-Directed as previously implemented) to simplify user choice and developer effort.
        *   **Consistent Orientation:** Employ a default Dagre orientation (`'LR'` - Left-to-Right) that best serves the primary use cases, particularly for Character and Puzzle maps, ensuring predictability. This was a key change to resolve previous layout errors.
        *   **Adequate Spacing:** Utilize Dagre's layout parameters (e.g., `nodesep`, `ranksep`, and internal padding for compound nodes like `nodePadding`, `rankPadding`) to ensure sufficient whitespace within and between groups, and between individual nodes. These were adjusted (e.g., `ranksep: 120`, `nodesep: 70`) to suit the 'LR' orientation.
    *   **Benefit:** A cleaner, more predictable layout reduces visual clutter and makes the graph easier to parse.

*   **3. Optimized Information Display on Nodes & Edges (Leveraging Color and Hover Text):**
    *   **Principle:** Provide the right amount of information at the right time, balancing immediate visual clarity with access to comprehensive details. This involves minimizing on-node/on-edge text by strategically using color-coding and making detailed information readily available via hover interactions (tooltips).
    *   **Implementation - Node Information Strategy:**
        *   **Color-Coding for Type Identification:**
            *   *Node Body:* The primary visual cue for an entity's fundamental type (Character, Element, Puzzle, Timeline) will be its background color and associated icon, as currently defined in `EntityNode.jsx` (via `getEntityPresentation`). This allows users to quickly differentiate node categories without reading explicit type labels on every node.
            *   *Node Chips:* Secondary attributes (e.g., an Element's `Basic Type` like "Prop" or "Container", a Character's `Tier` like "Core") will be displayed as small, color-coded chips on the node. Chip colors will be consistent with their primary entity type or a distinct scheme if representing sub-status, providing another layer of quick visual information.
        *   **Dynamic & Contextual Node Labels:**
            *   *Minimal Default Labels:* At wider zoom levels or for less central nodes, on-node text labels will be kept to a minimum – potentially showing only a truncated version of the entity's `Name` (from `graphData.nodes[n].name`) or a highly abbreviated identifier. The goal is to ensure node distinctiveness without clutter.
            *   *Zoom-Based Detail Expansion:* As users zoom in, node labels will progressively reveal more of the `Name`. This will be handled within `EntityNode.jsx` by responding to React Flow's zoom state.
            *   *Central/Selected Node Emphasis:* The central entity of the map and any user-selected nodes may display slightly more label detail by default.
        *   **Comprehensive Tooltips for Detail-on-Demand (Implemented May 24, 2025):**
            *   *Primary Detail Source:* Tooltips (activated on hover, managed by `EntityNode.jsx` and its `NodeTooltipContent` sub-component) serve as the primary mechanism for accessing the full details of an entity.
            *   *Tooltip Content (as per `EntityNode.jsx` enhancements):* Tooltips display:
                *   Full `Name` (preferring `properties.name`, then `label`).
                *   Entity `Type` (displaying `properties.type` if more specific than the general node type).
                *   "Key Properties" section with type-specific attributes (e.g., Character: Tier, Role, Primary Action Snippet; Element: Basic Type, Status; Puzzle: Timing, Owner Name; Timeline: Date String, Participant Summary).
                *   `properties.fullDescription` if available.
    *   **Implementation - Edge Information Strategy:**
        *   **Color-Coding for Relationship Category:**
            *   Edge colors will continue to be a primary means of differentiating the *category* of a relationship, as defined in `transformToGraphElements.js` (`edgeStyles`) and rendered by `CustomEdge.jsx`. For example:
                *   `dependency` edges (Orange): For "Requires," "Rewards" links to Puzzles.
                *   `containment` edges (Light Blue, dashed): For "Contains," "Inside" links for Elements.
                *   `character` edges (Indigo): For "Owns," "Associated With" involving Characters.
                *   `timeline` edges (Pink): For "Participates In," "Evidence For" involving Timeline events.
                *   `association` (Green) / `default` (Grey) for other types.
            *   This color-coding helps users rapidly understand the nature of connections without needing to read every label.
        *   **Concise On-Edge Labels:**
            *   On-edge text labels will display the `shortLabel` (e.g., "Owns," "Requires," "Contains") from `graphData.edges[e].data.shortLabel`. These should be brief and directly indicative of the relationship type.
        *   **Contextual Tooltips for Full Edge Semantics:**
            *   Tooltips on edges (managed by `CustomEdge.jsx`) will display the full `contextualLabel` (e.g., "Character A (Character) --Owns--> Element B (Prop)") from `graphData.edges[e].data.contextualLabel`, providing unambiguous detail about the source, target, and relationship when needed.
    *   **Benefit:** This multi-layered approach (color -> concise on-screen labels -> detailed tooltips) minimizes visual noise on the map itself, making it cleaner and easier to scan for patterns and primary connections. Detailed information remains easily accessible on demand, supporting both quick overviews and in-depth exploration. This directly aligns with the goal of reducing cognitive load and making the map more intuitive.

*   **4. Intelligent Edge Display (Leveraging Grouping):**
    *   **Principle:** With robust visual grouping via compound nodes, the need for complex edge pruning for "Single Point of Connection" (SPOC) might be reduced, as the grouping itself handles much of the visual simplification.
    *   **Implementation:**
        *   The primary means of simplifying edge views will be the strong visual grouping of nodes within compound parents. This inherently localizes many edges.
        *   The existing `filterGraph.js` SPOC logic will be re-evaluated. If compound grouping is highly effective, SPOC might be simplified or its parameters adjusted to only prune genuinely redundant inter-group edges, or it might be deferred if the initial grouped layout is sufficiently clear. Basic depth and type-based filtering will remain.
    *   **Benefit:** Clearer pathways between major entities or groups, with less visual distraction from potentially redundant direct links if a clear grouped path exists.

These revised principles will guide the technical implementation of the Relationship Mapper, ensuring the frontend presents the narrative web in the most understandable and actionable way, leveraging the strengths of Dagre for hierarchical layout and React Flow for rendering. The aim is to move from a map that "shows all data" to one that "explains key relationships" effectively.

**7. Assumptions & Dependencies**
*   **The Notion workspace structured precisely according to Section 4 is maintained.** Unauthorized changes to this Notion structure will break the tool.
*   Notion API remains stable, accessible, and its features support the required operations.
*   The initial data import from source CSVs and Markdown files has correctly established the baseline content and structure in Notion.
*   **The BFF's `/graph` endpoints consistently provide valid `graphData` objects structured according to Section 4.E.** The frontend `RelationshipMapper` now uses this `graphData` as its sole source for graph construction.

**8. Future Considerations (Out of Scope for current phases unless specified in Action Plan - Section 9)**
*   Full, robust parsing (beyond minimal `SF_RFID`) of structured data from Rich Text for memory attributes, if the minimal approach (Action Plan Phase 2, Step 5) proves insufficient long-term.
*   **Re-evaluation of true Dagre compound node capabilities...** (This item is now addressed by the focused rebuild outlined in Action Plan Section 9, Phase 1, Step 2, which adopts Dagre compound nodes as the core strategy.)
*   **Enhanced Interactive Group Management:**
    *   Interactive in-place node expansion/collapse for compound groups within the Relationship Mapper (e.g., allowing users to collapse a Puzzle's inputs/outputs or a Container's contents to reduce clutter on demand). This is now more feasible with the adoption of a true compound node architecture.
    *   Consideration for user-defined or dynamic grouping beyond the automatic semantic grouping if advanced use cases emerge.
*   **Advanced Filtering & Highlighting:**
    *   More sophisticated filtering options beyond simple type toggles (e.g., filter by specific narrative threads, status, or custom tags if added to data).
    *   Path highlighting between selected nodes or to trace specific relationship chains.
*   Visual diffing of narrative states or versions.
*   Integration with a dedicated task management or playtesting feedback system.
*   Advanced "narrative health check" analytics (e.g., identifying orphaned elements, unlinked puzzles, or circular dependencies – the new layout might make some of these more visually apparent).
*   Mobile/tablet responsiveness for read-only viewing.
*   **Refined Layout Customization (Post-Rebuild):** Once the core Dagre compound node layout is stable and effective, minor, well-justified layout customization options (e.g., alternative Dagre orientations like 'LR' if beneficial for specific views, or user-adjustable spacing parameters within defined limits) could be revisited if strong user needs emerge, but the primary goal remains a highly effective default.
*   **Fullscreen Control Panel - Future Polish:** Future UX considerations for the fullscreen control panel could include user-initiated collapsibility or draggability, especially to accommodate varied screen sizes, though the current implementation prioritizes consistent availability.
*   **Memoization Dependencies in `useGraphTransform.js`:** The `useMemo` hook in `useGraphTransform.js` relies on `JSON.stringify` for object-based dependencies (nodeFilters, edgeFilters, layoutOptions). While functional, this means changes in key order or object structure (if not consistently managed before stringification) could lead to unnecessary recalculations. This is a minor point for future awareness if performance optimization in this hook becomes critical.

**9. Action Plan & Next Steps**

This section outlines the current, active plan for StoryForge refinement and advancement as of **May 24, 2025**.

**Overarching Goal for All Phases:** Ensure all project documentation is consistent and up-to-date, with this `StoryForge PR.txt` document serving as the definitive "gold standard" source of truth. Progress will be tracked at each step.

**Development Methodology Notes:**
*   **Branching:** All work for this action plan should occur on dedicated feature branches (e.g., `feature/mapper-rebuild-phase1-step2`), which are then merged into `master` via Pull Requests.
*   **Iterative Work & Canvas Usage (If applicable with AI Assistant):** For complex modifications, AI assistant's canvas features might be used for temporary versions before finalizing code. Push updates to feature branches at appropriate checkpoints.

**Phase 1: Codebase Hygiene, Documentation Synchronization & Critical Mapper UX Foundation**
*Focus: Cleaning up, ensuring documentation is accurate, and making immediate high-value improvements to the Relationship Mapper's core usability.*

**1. Initial PRD Synchronization & Technical Debt Cleanup Kick-off (Concurrent Processes):**
    *   **1A. PRD Gold Standard - Initial Pass & Version Bump:**
        *   *Why:* Ensure PRD is a reliable source of truth.
        *   *Where:* `StoryForge PR.txt` document (this document).
        *   *What:* Updated document to v3.2.1 on May 19, 2025. Version v3.3.0 on May 20, 2025. This current update brings it to v3.3.1.
        *   **Status: COMPLETED**

    *   **1B. Technical Debt Cleanup & Code Refinements (High Priority - Ongoing):**
        *   *Why:* Remove confusing, non-functional, or redundant code. Fix dependency issues for clarity, stability, and consistency.
                        *   *Tasks & Specific File Locations:*
            *   **Backend Tests:**
                *   Delete deprecated test files: `storyforge/backend/tests/utils/propertyMapper.test.js`, `storyforge/backend/tests/utils/notionPropertyMapperAsync.test.js`, `storyforge/backend/tests/integration/puzzleEndpoints.test.js`.
                *   **Status: COMPLETED** (Manually deleted from `dev-phase1-updates` branch before merge to master on May 19, 2025)
            *   **Backend Dependencies:**
                *   Add `node-cache` to dependencies in `storyforge/backend/package.json`.
                *   **Status: COMPLETED** (Merged to master on May 19, 2025)
            *   **Backend Logic:**
                *   Refactor `globalSearch` in `storyforge/backend/src/controllers/notionController.js` for robust mapper name generation.
                *   **Status: COMPLETED** (Merged to master on May 19, 2025)
            *   **Frontend Tests:**
                *   Delete or heavily refactor `storyforge/frontend/src/components/RelationshipMapper/RelationshipMapper.test.jsx` (currently tests outdated `relationshipData` prop). Migrate valuable interaction tests to a `graphData`-centric approach.
                *   **Status: COMPLETED (Marked for manual deletion on May 19, 2025)**
            *   **Frontend Utils:**
                *   Investigate and likely delete `storyforge/frontend/src/components/RelationshipMapper/relationshipUtils.js` (contains remnants of an old client-side graph construction approach, likely unused).
                *   **Status: COMPLETED (Marked for manual deletion on May 19, 2025)**
            *   **Frontend Dependencies:**
                *   Remove `react-flow-renderer` from `storyforge/frontend/package.json`.
                *   **Status: COMPLETED** (Merged to master on May 19, 2025)
                *   Remove duplicate `@xyflow/react` from the root `package.json`.
                *   **Status: COMPLETED** (Merged to master on May 19, 2025)
                *   Verify/correct Playwright version in `storyforge/frontend/package.json`.
                *   **Status: COMPLETED (Verified on May 19, 2025 - version is current and correct)**
            *   **Frontend Logic:**
                *   Review and refine edge styling logic in `storyforge/frontend/src/components/RelationshipMapper/transformToGraphElements.js`.
                *   **Status: COMPLETED** (Merged to master on May 19, 2025)
        *   *What (Achieved/Goal):* A cleaner, more maintainable codebase. Updated `package.json` files. Fewer misleading/broken tests.
        *   *(Detailed tasks and statuses as per PRD v3.2.1 - all marked COMPLETED)*
        *   *(All sub-tasks previously listed under this item were COMPLETED as of PRD v3.3.0)*
        *   **Status: COMPLETED**

**2. RelationshipMapper - Focused Rebuild for Core UX & Layout Foundation (High Priority):**

    *   **A. Rationale for Rebuild & Goals:**
            *   **UI/UX Challenges with Previous Approach:** Extensive testing and user feedback (including analysis of visual outputs from "Alex Reeves's Map" and others) revealed that the prior multi-layout strategy ("Dagre + Orbiting," Radial, Force-Directed) and manual orbiting logic for Dagre layouts did not consistently or clearly meet core user needs. Key issues included:
            *   **Failure to "Tell a Story":** Maps did not provide an at-a-glance understanding of crucial hierarchical relationships, such as the contents of a container Element or the set of elements involved in a Puzzle.
            *   **High Cognitive Load:** Users were required to manually trace numerous edges and interpret truncated labels to understand fundamental groupings.
            *   **Ineffective Visual Grouping:** The "Dagre + Orbiting" strategy, despite iterations, failed to produce distinct and intuitive visual clusters for parent-child relationships (e.g., an Element and its contained items; a Puzzle and its inputs/outputs). The manual "orbiting" often resulted in child nodes appearing disconnected or arbitrarily placed relative to their intended parent.
            *   **Label Truncation:** Aggressive label truncation made many nodes unidentifiable without interaction, severely hindering quick comprehension.
            *   **UI Inconsistencies:** Issues like the inconsistent visibility of map controls (especially in fullscreen mode) detracted from usability.
        *   **Engineering Complexity:** Supporting multiple complex layout algorithms (Radial, Force-Directed, and the manual Dagre+Orbiting) with their distinct state management and UI controls led to significant code complexity in `layoutUtils.js`, `useGraphTransform.js`, `RelationshipMapper.jsx`, `useLayoutManager.js`, and `useRelationshipMapperUIState.js`. This complexity made the system difficult to debug, maintain, and extend reliably.
        *   **Strategic Decision:** Based on these findings, a decision has been made to undertake a focused rebuild of the Relationship Mapper's core layout and rendering logic. This rebuild prioritizes a single, robust, and clear hierarchical layout strategy designed to effectively visualize the narrative structure as defined by the user personas and use cases (PRD Section 6.B).
        *   **Primary Goal:** To deliver a Relationship Mapper that is intuitive, provides clear visual groupings for key hierarchical relationships (containers, puzzles), significantly reduces cognitive load, and is built on a more maintainable and focused engineering foundation.
        *   (No changes from PRD v3.2.1 - UI/UX Challenges, Engineering Complexity, Strategic Decision, and Primary Goal sections remain the same)

    *   **B. Revised Architectural Approach for Relationship Mapper:**
            *   (Largely as defined in PRD v3.2.1, with clarifications on current state and debugging findings based on May 20, 2025 analysis)
        *   **Input Data Structure:** The mapper will continue to consume the `graphData` object (nodes and edges with their properties, including `edge.data.shortLabel`) provided by the Backend-for-Frontend (BFF) as specified in PRD Section 4.E. It's noted that the `RelationshipMapperContent` component may initially render with `props.graphData` as `undefined` before data is fully fetched and propagated; the UI and subsequent hooks like `useGraphTransform.js` must handle this initial state gracefully.
        *   **Primary Layout Strategy (Exclusive):**
            *   **Engine:** Dagre (`dagre.js`) will be the *exclusive* graph layout engine used. Alternative layout options (Radial, Force-Directed) and their associated UI controls have been removed.
            *   **Layout Orientation:** A default orientation ('TB' - Top-to-Bottom) is standard.
        *   **Visual Grouping Mechanism (Compound Nodes):**
            *   **Logical Group Identification:** The frontend (`useGraphTransform.js`) assigns `node.data.parentId` to Element nodes (for "Contains") and Puzzle nodes (for "Required For" / "Rewards") based on `edge.data.shortLabel`. It also sets a `node.data.isActualParentGroup` flag for nodes that will act as parents.
            *   **Dagre Compound Nodes (`layoutUtils.js` - `getDagreLayout`):**
                *   **Current Status & Understanding (as of May 20, 2025):**
                    *   Dagre's `compound: true` feature and `g.setParent()` calls are now active and stable within `layoutUtils.js`. The `dagre.layout(g)` function executes successfully, producing a compound graph when `graphData` is present.
                    *   The previously noted `TypeError: Cannot set properties of undefined (setting 'rank')` has been addressed through careful node/parent validation (including a specific check to prevent self-parenting) and robust error handling within the layout function.
                *   **Target Implementation (Post-Debugging):** Fully utilize Dagre's `compound: true` feature. Call `g.setParent(childNode.id, parentNode.id)` for all nodes with an assigned `parentId`. Set initial visual dimensions for all nodes in `g.setNode()`. Configure Dagre's graph-level layout options (e.g., `nodesep`, `ranksep`, `nodePadding`, `rankPadding`) to manage spacing effectively.
            *   **React Flow Parent Rendering (`useGraphTransform.js`):** The hook maps `node.data.parentId` to React Flow's native `node.parentNode` attribute, enabling hierarchical rendering.
        *   **Node Presentation (`EntityNode.jsx`):**
            *   Parent/Group Nodes: Nodes acting as parents are styled distinctly by `EntityNode.jsx` using the `data.isActualParentGroup` flag.
            *   Child Nodes: Render as standard `EntityNode`s within their parent's bounds.
            *   Dynamic Label Display: Implemented using `useViewport()` for zoom-based label detail.
        *   **Edge Presentation (`CustomEdge.jsx`):** (No changes to current implementation planned in this step; optional refinements deferred).
            *   Edges will continue to use `CustomEdge.jsx`.
            *   Consideration will be given to subtly varying edge styles (e.g., weight, opacity) for edges *within* a group versus edges *between* groups or top-level nodes, to reinforce visual hierarchy.
        *   **Simplification of State and UI:**
            *   `RelationshipMapper.jsx`, `useLayoutManager.js`, and `useRelationshipMapperUIState.js` have been simplified by removing states and UI elements for deprecated layouts.
            *   The manual "orbiting children" logic (`ClusterHull.jsx`) has been removed.
            *   The map controls panel is now persistent in fullscreen mode, implemented as a floating panel.
        *   (Content remains unchanged from v3.3.0, but a backend modification was made on May 21, 2025, to `storyforge/backend/src/controllers/notionController.js` (SHA `37e3b9ab1cabccbe0873fc0986c2cf01190539d0`) to ensure `getCharacterGraph` generates "Contains" edges (with `shortLabel: "Contains"`) in the `graphData` for elements that are direct contents of 1st-degree container Elements owned by or associated with the central character. This is critical for enabling frontend grouping logic on Character maps. Cache keys for graph endpoints were also versioned to v3.1.)

    *   **C. Detailed Implementation Tasks & Status (as of May 24, 2025):**
        *   **1. PRD Alignment (This Document):**
            *   Status: **COMPLETED** (This document, v3.4.0, reflects the current understanding and plan).
        *   **2. Data Transformation Refinement (`useGraphTransform.js`):**
            *   Status: **COMPLETED**. `parentId` assignment logic verified. `node.parentNode` mapping enabled. `isActualParentGroup` flag added for parent styling. Debug logging related to parentId assignment states (all disabled, Required For only, Rewards only, all enabled) was utilized and can be maintained for future debugging.
            *   **Notes:** The `useMemo` hook in `useGraphTransform.js` relies on `JSON.stringify` for object-based dependencies. This remains a minor point for future awareness.
        *   **3. Layout Engine Overhaul (`layoutUtils.js` - `getDagreLayout`):**
            *   Status: **COMPLETED**.
            *   Removed `getCustomRadialLayout` and `getForceDirectedLayout`: **COMPLETED**.
            *   Removed old Dagre "inflated hub size" and "orbit children" logic: **COMPLETED**.
            *   Using standard node dimensions for Dagre `g.setNode()`: **COMPLETED**.
            *   Implementation of iteration to call `g.setParent(childNode.id, parentNode.id)`: **COMPLETED**.
            *   **Resolution Summary:** The `TypeError: setting 'rank'` was resolved by changing `rankdir` to `'LR'` and adjusting associated Dagre spacing options (`nodesep: 70`, `ranksep: 120`, `nodePadding: 25`, `rankPadding: 60`) for optimal left-to-right hierarchical display. Cycle detection for parent-child assignments was also implemented as a preventative measure. Debug logs specific to these changes were added and can be maintained.
        *   **4. Node Rendering Enhancements (`EntityNode.jsx`):**
            *   Status: **COMPLETED**. Dynamic label rendering based on zoom level implemented. Distinct styling for nodes with `data.isActualParentGroup` implemented. Further enhanced with comprehensive tooltips displaying full label, type, key properties, and full description, as per PRD Section 6.D.
        *   **5. Main Mapper Component Simplification (`RelationshipMapper.jsx`, `useLayoutManager.js`):**
            *   Status: **COMPLETED**. UI elements and state logic for Radial/Force-Directed layouts and Dagre orientation changes removed. `ClusterHull.jsx` removed. `useLayoutManager` simplified. Persistent floating panel for map controls is implemented and functional in normal/fullscreen modes. Robust `graphData` handling confirmed.
        *   **6. Edge Styling (Optional Refinement - `CustomEdge.jsx`):**
            *   Status: **VERIFIED**. Verified that `CustomEdge.jsx` correctly displays `data.shortLabel` on the path and `data.contextualLabel` in tooltips.
        *   **7. Filtering Logic Review (`filterGraph.js`):**
            *   Status: **COMPLETED (Revision 1)**. "Single Point of Connection" (SPOC) edge pruning logic remains simplified/disabled. Basic depth filtering is now compound-aware. Orphan removal logic revised.
        *   **8. Comprehensive Testing:**
            *   Utilize diverse test cases based on PRD Section 6.B (User Personas & Use Cases), focusing on Character, Element (container), and Puzzle maps.
            *   Verify that logical groups (container contents, puzzle I/O) are visually cohesive and easy to interpret with the `rankdir: 'LR'` layout.
            *   Assess overall graph readability, edge crossings, and spacing.
            *   Test label display at various zoom levels.
            *   Confirm UI consistency and control accessibility.
            *   Status: **UNBLOCKED**. Testing of the `rankdir: 'LR'` compound node layout is now the next step for mapper validation.

    *   **D. Key UI/UX Improvements Addressed by this Rebuild:**
        *   **Hierarchical Clarity:** Achieved through direct visual representation of parent-child relationships (items in containers, elements tied to puzzles) via Dagre compound nodes with `rankdir: 'LR'`.
        *   **Reduced Cognitive Load:** Simplified visual structure due to a single, focused layout strategy and fewer user-configurable layout options make the map easier to understand and use.
        *   **Improved "At-a-Glance" Understanding:** Users should be able to quickly discern the main relationships and groupings relevant to the central entity.
        *   **Enhanced Label Readability:** Dynamic labels will reduce clutter while ensuring information is accessible. Comprehensive tooltips provide full details on demand.
        *   **Consistent UI Controls:** Achieved with the persistent floating panel for map controls, ensuring improved accessibility and behavior in all view modes.

    *   **E. Expected Outcome / Definition of Done for this Step:**
        *   The Relationship Mapper primarily uses a Dagre-based layout with `rankdir: 'LR'` and compound nodes. **COMPLETED**.
        *   Alternative layout options (Radial, Force-Directed) and manual orbiting/hull logic are removed from the codebase. **COMPLETED**.
        *   Node labels are dynamically adjusted for readability based on context (e.g., zoom), and comprehensive tooltips are implemented. **COMPLETED**.
        *   The UI for map controls is simplified and functions correctly in all view modes. **COMPLETED**.
        *   The mapper demonstrably meets the core visualization needs for Character, Element (container), and Puzzle map use cases as outlined in PRD Section 6.B.
        *   The relevant codebase (`RelationshipMapper/` directory) is cleaner, more maintainable, and focused. **COMPLETED**.
        *   This PRD section (and related ones like 6.D) are updated to accurately reflect the new implementation. **COMPLETED**.
    *   **Status: COMPLETED**

**3. Full PRD Update & Documentation Synchronization (Completion of Initial Pass):**
    *   *Why:* Solidify `StoryForge PR.txt` (this document) as the single, accurate source of truth. Align or archive other potentially conflicting project documents.
    *   *Where:* This document (`StoryForge PR.txt`), and any auxiliary project documents. Key auxiliary documents to review/archive include `StoryForge Phase 2 Glowup*.txt` and `frontend-glowup-bundle.txt`.
    *   *Tasks:*
        *   Systematically update all sections in this document based on findings and work completed in Phase 1.
        *   Update mapper architecture descriptions, layout strategies, testing strategy sections (Section 10), dependency lists, and milestone statuses.
        *   Merge any still-relevant, unique content from auxiliary documents into this PRD. Clearly mark these auxiliary documents as "ARCHIVED" or "SUPERSEDED by StoryForge PR.txt v3.4.0 (or current version)" to avoid future confusion.
    *   *What (Goal):* This document (`StoryForge PR.txt`) has been updated to v3.4.0 (May 24, 2025), reflecting all findings and work completed in Phase 1. Auxiliary documents (`StoryForge Phase 2 Glowup*.txt`, `frontend-glowup-bundle.txt`) are now considered superseded by this PRD for future planning but can be retained as historical artifacts of the development process.
    *   **Status: COMPLETED**

**Phase 2: Advanced Mapper Enhancements, Minimal Memory Attribute Implementation, and UI/UX Polish**
*(Overall Status: COMPLETED)*

4.  **RelationshipMapper - Advanced UX Enhancements:**
    *   *Why:* Build on the stable foundation from Phase 1 to make the mapper more informative and interactive.
    *   *Where:* `storyforge/frontend/src/components/RelationshipMapper/` components, UI state hooks, filtering logic, backend data mappers.
    *   *Tasks:* Implement/refine information-rich tooltips, node chips, edge labels. Implement/refine advanced filtering UI & logic. Address UI/UX polish items.
    *   *What (Goal):* A significantly more interactive and informative Relationship Mapper.
    *   **Status: COMPLETED**.
        *   Implemented and connected advanced filtering capabilities in the Relationship Mapper for 'Act Focus', 'Themes', and 'Memory Sets'. Backend (`notionPropertyMapper.js`) now populates these properties in `graphData`.
        *   Node tooltips (`EntityNode.jsx`) were updated to display these attributes, providing better user context for filtering actions.
        *   UI controls for these filters are functional in the Relationship Mapper.

5.  **Define & Implement MINIMAL Memory Attribute Handling (Re-prioritized):**
    *   *Why:* Address the previously identified feature gap for essential memory identification (e.g., RFID).
    *   *Tasks & Details:*
        *   **Backend Parsing (`storyforge/backend/src/utils/notionPropertyMapper.js`):** Logic implemented in `mapElementWithNames` to parse `SF_RFID: [value]`, `SF_ValueRating: [1-5]`, and `SF_MemoryType: [Personal|Business|Technical]` from the `Description/Text` field of memory-type Elements. These are stored in `element.properties`.
        *   **Frontend Display (`storyforge/frontend/src/pages/ElementDetail.jsx`):** Updated to display the parsed `element.properties.parsed_sf_rfid`.
    *   *What (Goal):* Basic RFID, Value Rating, and Memory Type parsing from Element descriptions and display in the UI. PRD Section 4.D updated.
    *   **Status: COMPLETED**.

6.  **Refined Visual Presentation of Hierarchies in Mapper:**
    *   *Why:* Ensure clear visual demarcation of compound groups.
    *   *Tasks & Details:* Enhanced styling for parent (compound) nodes in `EntityNode.jsx` to improve visual distinction of groups (background, border, shadow adjustments). Dagre layout options (`rankdir: 'LR'`) and spacing were confirmed and tuned for optimal hierarchical display.
    *   **Status: COMPLETED**.

7.  **UI/UX Polish for Core Views (List & Detail Pages):**
    *   *Why:* Standardize page layouts and improve filter consistency.
    *   *Tasks & Details:* Ensured all four entity detail pages (`CharacterDetail`, `ElementDetail`, `PuzzleDetail`, `TimelineDetail`) now share a consistent and robust two-column layout with a toggleable Relationship Mapper and standardized data handling. List page filtering capabilities were reviewed and enhanced (e.g., server-side `actFocus` for Timeline list page, server-side filtering for `narrativeThreadContains` across all list views).
    *   **Status: COMPLETED**.

8.  **Comprehensive Testing (Moved from Phase 1):**
    *   *Why:* Validate the significant changes made in Phase 1 & 2.
    *   *Tasks & Details:* A conceptual review and focused testing of the Relationship Mapper (filters, `rankdir: 'LR'` layout, tooltips), detail page consistency, list page filters (including server-side `actFocus` for Timeline & `narrativeThreadContains`), and memory attribute display for Phase 1 & 2 changes has been completed.
    *   *What (Goal):* Initial validation of Phase 1 & 2 features.
    *   **Status: COMPLETED (Conceptual Pass)**. Interactive QA is the next step for thorough validation.

**Phase 3: Advanced Design Views - Puzzle Flow, Narrative Threads, Memory Economy Foundations (COMPLETED)**
*Focus: Introduce specialized views to assist with specific design and balancing tasks.*

9.  **Puzzle Flow View (Foundational):**
    *   *Why:* Provide Puzzle Designers with a clear visualization of individual puzzle dependencies.
    *   *Tasks & Details:*
        *   Backend: New endpoint `/api/puzzles/:id/flowgraph` created. Service function `fetchPuzzleFlowDataStructure` fetches the central puzzle, its input/output elements (Puzzle Elements, Rewards, Locked Item), parent/sub-puzzles, and owners. Controller `getPuzzleFlowGraph` transforms this into a `graphData` structure with specific node types (Puzzle, Element, Character) and edge types (REQUIRES, REWARDS, UNLOCKS_ITEM, UNLOCKS_PUZZLE, LEADS_TO_PUZZLE, OWNS_PUZZLE). Element nodes include `isInput`/`isOutput` flags.
        *   Frontend: New page `/puzzles/:id/flow` (`PuzzleFlowPage.jsx`) created. Uses React Flow with a Dagre 'LR' layout. Displays the fetched graph, allowing users to see direct upstream and downstream connections for a selected puzzle. Nodes link to their respective detail pages.
    *   *What (Goal):* A functional, read-only view showing direct inputs, outputs, and puzzle connections for a single puzzle.
    *   **Status: COMPLETED.**

10. **Narrative Thread Tracker (Initial Version):**
    *   *Why:* Allow Narrative Designers to track the propagation of specific narrative threads across all entity types.
    *   *Tasks & Details:*
        *   Backend: Endpoint `/api/narrative-threads` (previously `/api/narrative-threads/unique`) provides a list of all unique "Narrative Threads" values from Notion. List endpoints for Characters, Elements, Puzzles, and Timeline Events updated to support filtering by `?narrativeThreadContains=ThreadName`.
        *   Frontend: New page `/narrative-thread-tracker` (`NarrativeThreadTrackerPage.jsx`) created.
            *   A dropdown allows users to select a unique narrative thread.
            *   When a thread is selected, the page fetches all Characters, Elements, Puzzles, and Timeline Events associated with that thread using the filtered list APIs.
            *   Items are displayed in a chronological list, primarily anchored and sorted by Timeline Event dates. Entities associated with each event (or heuristically linked by Act Focus) are grouped under that event.
            *   Entities not directly tied to a Timeline Event in the selected thread are listed in a separate "Orphaned Items" section.
            *   All listed items link to their detail pages.
    *   *What (Goal):* A page where users can select a narrative thread and see all related entities, presented in a contextually relevant, chronologically-driven order.
    *   **Status: COMPLETED.**

11. **Memory Economy View (Foundational):**
    *   *Why:* Provide a dashboard to understand the value and distribution of memory-type elements.
    *   *Tasks & Details:*
        *   Backend: `mapElementWithNames` in `notionPropertyMapper.js` enhanced to parse `SF_ValueRating: [1-5]` and `SF_MemoryType: [Personal|Business|Technical]` from Element descriptions, alongside existing `SF_RFID` parsing. These are stored in `element.properties`. The `/api/elements` endpoint now supports a `?filterGroup=memoryTypes` query parameter for efficient server-side fetching of only memory-type elements.
        *   Frontend: New page `/memory-economy` (`MemoryEconomyPage.jsx`) created.
            *   Fetches memory-type elements using the new server-side filter.
            *   Calculates `baseValueAmount` (from `sf_value_rating`), `typeMultiplierValue` (from `sf_memory_type`), and `finalCalculatedValue`.
            *   Displays these memories in a `DataTable` with columns for Name, RFID, Value Rating, Base Value, Memory Type, Multiplier, Final Value, and a simplified "Discovered Via" field.
    *   *What (Goal):* A sortable, tabular view of memory elements with their calculated economic values. (Group Set bonuses and more complex economic interactions are future considerations).
    *   **Status: COMPLETED.**

**Phase 4: Editing Capabilities, Further Refinements & Advanced Features**
*(All items in this phase are PENDING - Renumbered from original plan)*

12. **Prepare for and Implement Editing Capabilities:**
    *   *Why:* Enable users to modify Notion data directly through StoryForge, a core long-term goal.
    *   *Where:* This will involve significant new backend work (new API endpoints in `notionController.js`, write logic in `notionService.js`, potentially new mappers in `notionPropertyMapper.js` for constructing Notion API payloads) and frontend work (editing forms, UI components, state management for optimistic updates, error handling for writes).
    *   *Tasks:* Design and document editing workflows, data validation schema (client and server-side). Implement CRUD operations for entities and relationships. Address data synchronization and potential conflict resolution strategies.
    *   *What (Goal):* Core editing features implemented. Relevant PRD sections created/updated.
    *   **Status: PENDING**
13. **Integrate Accessibility Focus into Ongoing Workflow:**
    *   *Why:* Ensure StoryForge is usable by people with diverse abilities, a non-functional requirement.
    *   *Where:* All frontend components, especially interactive ones like the Relationship Mapper and any new editing interfaces.
    *   *Tasks:* For new components and major refactors, include accessibility checks (keyboard navigation, ARIA attributes, color contrast) in development and testing. Review key UI components against WCAG guidelines.
    *   *What (Goal):* Improved accessibility of the application.
    *   **Status: PENDING**
14. **Continue with Further Enhancements / Next Development Cycle:**
    *   **Status: PENDING**

6.  **Prepare for and Implement Editing Capabilities:**
    *   *Why:* Enable users to modify Notion data directly through StoryForge, a core long-term goal.
    *   *Where:* This will involve significant new backend work (new API endpoints in `notionController.js`, write logic in `notionService.js`, potentially new mappers in `notionPropertyMapper.js` for constructing Notion API payloads) and frontend work (editing forms, UI components, state management for optimistic updates, error handling for writes).
    *   *Tasks:* Design and document editing workflows, data validation schema (client and server-side). Implement CRUD operations for entities and relationships. Address data synchronization and potential conflict resolution strategies.
    *   *What (Goal):* Core editing features implemented. Relevant PRD sections created/updated.
    *   **Status: PENDING**
7.  **Integrate Accessibility Focus into Ongoing Workflow:**
    *   *Why:* Ensure StoryForge is usable by people with diverse abilities, a non-functional requirement.
    *   *Where:* All frontend components, especially interactive ones like the Relationship Mapper and any new editing interfaces.
    *   *Tasks:* For new components and major refactors, include accessibility checks (keyboard navigation, ARIA attributes, color contrast) in development and testing. Review key UI components against WCAG guidelines.
    *   *What (Goal):* Improved accessibility of the application.
    *   **Status: PENDING**
8.  **Continue with Further Enhancements / Next Development Cycle:**
    *   **Status: PENDING**

**10. Testing Strategy**

**Testing Suite Status (as of May 24, 2025):**
*   Deprecated backend test files have been removed. The primary backend utility mapper test file is `storyforge/backend/tests/utils/notionPropertyMapper.test.js`, requiring ongoing expansion.
*   Frontend tests for `RelationshipMapper` (e.g., `RelationshipMapper.test.jsx`) require significant refactoring for `graphData` consumption, `parentId` assignment, Dagre compound node rendering (`rankdir: 'LR'`), and simplified controls.
*   **Key Debugging Findings for Layout Testing (Updated May 24, 2025):**
    *   The primary Dagre layout error (`TypeError: setting 'rank'`) has been resolved by adopting a `rankdir: 'LR'` layout. Testing should now focus on the visual efficacy and correctness of this layout.
*   E2E tests (Playwright) remain crucial and will be adapted for the rebuilt mapper, focusing on the `rankdir: 'LR'` compound layout and its behaviors.

A comprehensive testing strategy is crucial for the development of StoryForge. This includes:

*   **10.1. Unit Tests:**
    *   **Backend:** (Remains as previously stated)
    *   **Frontend:**
        *   Core UI components: `EntityNode.jsx` (dynamic labels, parent/group styling), `CustomEdge.jsx`.
        *   Utility functions:
            *   `transformToGraphElements.js`: Correct mapping from `graphData` to React Flow elements.
            *   `useGraphTransform.js`: Critical tests for `parentId` and `isActualParentGroup` assignment given various `graphData` inputs (including empty/initial `undefined` states). Test correct `nodes` and `edges` formation including `parentNode`.
            *   `layoutUtils.js` (`getDagreLayout`):
                *   Test correct handling of empty or minimal node/edge inputs (should not error).
                *   Once compound features are active and the current "rank" error is addressed, test with graph structures that might cause Dagre ranking issues (e.g., cycles in parent-child declarations, invalid parent IDs post-filtering, disconnected components within a compound setup) to ensure robust error handling or graceful degradation.
                *   Verify returned nodes have valid, numerically-defined positions upon successful layout (both flat and compound).
                *   Test that the fallback positioning logic in the `catch` block correctly assigns distinct, staggered positions if Dagre fails.
            *   `filterGraph.js`: Test filtering logic independently, including compound-aware depth filtering.
*   **10.2. Integration Tests:**
    *   **Backend:** (Remains as previously stated)
    *   **Frontend:**
        *   Test the full data flow: `graphData` prop in `RelationshipMapper.jsx` (covering initial `undefined` then populated states) -> `useGraphTransform.js` -> `filterGraph.js` -> `layoutUtils.js` (`getDagreLayout` with `rankdir: 'LR'`) -> nodes/edges rendered by React Flow.
        *   Verify that once `graphData` is populated and Dagre layout completes, parent-child relationships are correctly established and rendered hierarchically with the `rankdir: 'LR'` orientation. Tests must now specifically verify the correct visual rendering of Dagre compound node groupings.
        *   Test interactions with the simplified control panel in `RelationshipMapper.jsx`, ensuring it is accessible and functional in both normal and fullscreen modes.
*   **10.3. End-to-End (E2E) Tests:**
    *   Simulate real user scenarios using Playwright:
        *   Fetching and displaying maps: After `graphData` loads, verify key items (containers with contents, puzzles with I/O) are clearly grouped and visually distinct with the `rankdir: 'LR'` compound layout.
        *   Test dynamic label display at different zoom levels.
        *   Test tooltip accuracy for nodes and edges (including comprehensive node tooltips and short/contextual edge labels).
        *   Verify the consistent visibility, availability, and functionality of the map controls panel in both standard and fullscreen modes.
        *   Ensure the application handles the initial phase where `graphData` might be `undefined` without crashing, perhaps showing a loading state.
*   **10.4. Manual & Exploratory Testing (Updated May 21, 2025):**
    *   **Current Focus:** Verify visual and functional correctness of the `rankdir: 'LR'` compound layout across various datasets and use cases (PRD Section 6.B). Test node tooltip comprehensiveness and edge label/tooltip accuracy.
    *   Thoroughly test with various complex data sets. Evaluate the visual effectiveness of the `isActualParentGroup` styling. Observe behavior if `graphData` is slow to load or fails. Specifically test usability of map controls in fullscreen.
This testing strategy, with tests being added and updated alongside the focused rebuild as per the Action Plan (Section 9), will serve as a blueprint for building a resilient and reliable StoryForge application.

---
**Changelog**
*   v3.6.0 (May 26, 2025): Implemented Puzzle Flow View, initial Narrative Thread Tracker, and foundational Memory Economy View. Enhanced backend parsing for memory attributes (`SF_RFID`, `SF_ValueRating`, `SF_MemoryType`) and added server-side filtering for memory types and narrative threads.
*   v3.5.0 (May 25, 2025): Implemented minimal memory RFID parsing & display. Added advanced filtering (Act, Theme, Memory Set) to Relationship Mapper and relevant backend data population. Refined mapper's hierarchical visuals and parent node styling. Standardized detail page layouts. Added server-side `actFocus` filtering for Timeline. Completed initial testing pass for these Phase 1 & 2 features.
*   v3.4.0 (May 24, 2025): Resolved Dagre layout error by implementing `rankdir: 'LR'`. Enhanced node tooltips. Confirmed edge label/tooltip implementation. Updated Action Plan status for Phase 1 completion.
*   v3.3.1 (May 21, 2025): Updated Relationship Mapper action plan with detailed debugging steps for Dagre compound layout error. Documented backend fix for "Contains" edge generation and cache versioning.
*   v3.3.0 (May 20, 2025): Updated Relationship Mapper architecture, detailed layout strategy focusing on Dagre compound nodes. Documented current understanding of Dagre `rank` error and steps taken. Reflected completion of several Phase 1 cleanup tasks.
*   v3.2.1 (May 19, 2025): Initial Action Plan (Phase 1-3) added. Technical debt cleanup tasks detailed and status updated. PRD sections re-organized.
*   (Older versions omitted for brevity)
