Okay, this is excellent feedback and aligns well with what a designer would spot. The "hairball" effect in the relationship mapper is a classic problem when dealing with even moderately connected data, and the layout/whitespace issues are common refinement points.

Let's tackle this iteratively. I'll provide a new set of enhancements focusing primarily on:

1.  **Relationship Mapper Visuals & Layout (`layoutUtils.js`, `RelationshipMapper.jsx`, `EntityNode.jsx`):**
    *   Adjusting the layout algorithm to better handle density and attempt a more structured (less purely radial) distribution.
    *   Refining node appearance for better clarity at various zoom levels (within limits of current approach).
    *   Improving edge appearance.
2.  **Overall Page Layout (especially `CharacterDetail.jsx` and `AppLayout.jsx`):**
    *   Addressing the sidebar gap.
    *   Constraining main content width for better text readability, which also helps with perceived crowding.
    *   Refining the two-column layout in the profile section.
3.  **Visual Hierarchy and Polish on Detail Pages:**
    *   Improving typography and spacing within content sections.

I won't introduce a new library like `elkjs` for layout in this iteration to keep changes manageable, but I'll significantly refactor `layoutUtils.js`.

Here's the next set of proposed code changes:

--- START OF MODIFIED FILES ---

--- FILE: storyforge/frontend/src/theme.js ---
```jsx
import { createTheme } from '@mui/material/styles';

// Create a custom theme for StoryForge
const theme = createTheme({
  palette: {
    mode: 'dark',
    primary: {
      main: '#1e88e5', 
      light: '#90caf9', 
      dark: '#1565c0',
      contrastText: '#ffffff',
    },
    secondary: {
      main: '#ff5722', 
      light: '#ff8a65',
      dark: '#e64a19',
      contrastText: '#ffffff',
    },
    background: {
      default: '#0a0a0a', // Slightly darker default background
      paper: '#161616', // Paper color slightly distinct from default
    },
    text: {
      primary: 'rgba(255, 255, 255, 0.90)', // Brighter primary text
      secondary: 'rgba(255, 255, 255, 0.65)', // Brighter secondary text
      disabled: 'rgba(255, 255, 255, 0.38)',
    },
    success: {
      main: '#4caf50',
      contrastText: '#ffffff',
    },
    error: {
      main: '#f44336',
      contrastText: '#ffffff',
    },
    warning: {
      main: '#ff9800',
      contrastText: 'rgba(0, 0, 0, 0.87)', 
    },
    info: {
      main: '#2196f3',
      contrastText: '#ffffff',
    },
    divider: 'rgba(255, 255, 255, 0.20)', // More visible divider
  },
  typography: {
    fontFamily: '"Roboto", "Helvetica", "Arial", sans-serif',
    h1: { fontSize: '2.8rem', fontWeight: 500, letterSpacing: '-0.5px' },
    h2: { fontSize: '2.2rem', fontWeight: 500, letterSpacing: '-0.25px' },
    h3: { fontSize: '1.9rem', fontWeight: 500 },
    h4: { fontSize: '1.6rem', fontWeight: 600 }, // PageHeader title - bolder
    h5: { fontSize: '1.3rem', fontWeight: 500 },
    h6: { fontSize: '1.1rem', fontWeight: 500 },
    subtitle1: {
      fontSize: '1rem',
      fontWeight: 400,
      color: 'rgba(255, 255, 255, 0.75)', 
    },
    subtitle2: { // Used for field labels
      fontSize: '0.8rem', // Slightly smaller for compactness
      fontWeight: 600, 
      color: 'rgba(255, 255, 255, 0.6)', // Softer label color
      textTransform: 'uppercase', 
      letterSpacing: '0.75px',
      display: 'block', // Ensure it takes full width for alignment
      marginBottom: '2px',
    },
    body1: {
      fontSize: '0.95rem', // Slightly smaller body text for better density
      lineHeight: 1.6,
    },
    body2: {
      fontSize: '0.85rem',
      lineHeight: 1.5,
    },
    caption: {
      fontSize: '0.75rem',
      color: 'rgba(255, 255, 255, 0.5)',
    },
  },
  shape: {
    borderRadius: 6, // Slightly less rounded for a more "tool" feel
  },
  components: {
    MuiButton: {
      styleOverrides: {
        root: {
          textTransform: 'none', 
          borderRadius: 4, 
        },
      },
    },
    MuiAppBar: {
      styleOverrides: {
        root: {
          boxShadow: '0px 2px 4px -1px rgba(0,0,0,0.2), 0px 4px 5px 0px rgba(0,0,0,0.14), 0px 1px 10px 0px rgba(0,0,0,0.12)', // Add subtle shadow
          backgroundColor: '#161616', // Match paper
        },
      },
    },
    MuiDrawer: {
      styleOverrides: {
        paper: {
          backgroundColor: '#101010', // Slightly darker drawer
          borderRight: '1px solid rgba(255, 255, 255, 0.12)', 
        },
      },
    },
    MuiPaper: {
      styleOverrides: {
        root: {
          backgroundImage: 'none', 
        },
      },
      defaultProps: {
        elevation: 2, // Default paper elevation for more depth
      }
    },
    MuiCard: { // If you use cards
      styleOverrides: {
        root: {
          backgroundImage: 'none',
          backgroundColor: '#1a1a1a' // Slightly different card bg
        },
      },
      defaultProps: {
        elevation: 3,
      }
    },
    MuiTooltip: {
      styleOverrides: {
        tooltip: {
          backgroundColor: '#2c2c2c', 
          color: 'rgba(255, 255, 255, 0.9)',
          fontSize: '0.8rem',
          border: '1px solid rgba(255,255,255,0.2)'
        },
        arrow: {
          color: '#2c2c2c',
        },
      },
    },
    MuiChip: {
      styleOverrides: {
        root: {
          fontWeight: 500,
          padding: '2px 4px', // More compact chips
          height: 'auto',
          fontSize: '0.75rem',
        },
        icon: {
          marginLeft: '3px',
          marginRight: '-2px',
          fontSize: '1rem',
        }
      },
    },
    MuiListItemButton: {
      styleOverrides: {
        root: {
          '&.Mui-selected': {
            backgroundColor: 'rgba(30, 136, 229, 0.20)', // Slightly more prominent selection
            borderLeft: `3px solid ${'#1e88e5'}`, // Primary main for border
            paddingLeft: 'calc(1.5rem - 3px)', // Adjust padding for border
            '&:hover': {
              backgroundColor: 'rgba(30, 136, 229, 0.25)',
            },
          },
          '&:hover': {
            backgroundColor: 'rgba(255, 255, 255, 0.05)', // Subtle hover
          }
        },
      },
    },
    MuiTabs: {
      styleOverrides: {
        indicator: {
          height: 3,
          borderRadius: '3px 3px 0 0',
        }
      }
    },
    MuiTab: {
      styleOverrides: {
        root: {
          textTransform: 'none',
          fontWeight: 500,
          padding: '12px 16px', // Adjust tab padding
        }
      }
    },
    MuiDivider: {
      styleOverrides: {
        root: {
          borderColor: 'rgba(255, 255, 255, 0.15)' // Slightly lighter divider
        }
      }
    }
  },
});

export default theme;
```
---
--- FILE: storyforge/frontend/src/layouts/AppLayout.jsx ---
```jsx
import { useState, useEffect, useCallback } from 'react';
import { useNavigate, useLocation } from 'react-router-dom';
import {
  AppBar, Box, CssBaseline, Divider, Drawer, IconButton, List, ListItem, ListItemButton,
  ListItemIcon, ListItemText, Toolbar, Typography, useMediaQuery, Tooltip, Modal,
  TextField, List as MUIList, ListItem as MUIListItem, ListItemText as MUIListItemText,
  CircularProgress, InputAdornment, Alert, Link as MuiLink,
} from '@mui/material';
import { useTheme } from '@mui/material/styles';
import MenuIcon from '@mui/icons-material/Menu';
import ChevronLeftIcon from '@mui/icons-material/ChevronLeft';
import DashboardIcon from '@mui/icons-material/Dashboard';
import PeopleIcon from '@mui/icons-material/People';
import TimelineIcon from '@mui/icons-material/Timeline';
import ExtensionIcon from '@mui/icons-material/Extension';
import InventoryIcon from '@mui/icons-material/Inventory';
import SearchIcon from '@mui/icons-material/Search';
import { Link as RouterLink } from 'react-router-dom';
import { api } from '../services/api';

const drawerWidth = 240; // Adjusted back to 240 for a sleeker look

const navItems = [
  { text: 'Dashboard', icon: <DashboardIcon />, path: '/' },
  { text: 'Characters', icon: <PeopleIcon />, path: '/characters' },
  { text: 'Timeline', icon: <TimelineIcon />, path: '/timelines' },
  { text: 'Puzzles', icon: <ExtensionIcon />, path: '/puzzles' },
  { text: 'Elements', icon: <InventoryIcon />, path: '/elements' },
];

const getIconForType = (type) => {
  switch (type) {
    case 'characters': return <PeopleIcon fontSize="small" sx={{ mr: 1, color: 'primary.light' }} />;
    case 'timeline': return <TimelineIcon fontSize="small" sx={{ mr: 1, color: 'secondary.light' }} />;
    case 'puzzles': return <ExtensionIcon fontSize="small" sx={{ mr: 1, color: 'success.light' }} />;
    case 'elements': return <InventoryIcon fontSize="small" sx={{ mr: 1, color: 'info.light' }} />;
    default: return null;
  }
};

export default function AppLayout({ children }) {
  const theme = useTheme();
  const isMobile = useMediaQuery(theme.breakpoints.down('md'));
  const [open, setOpen] = useState(!isMobile); // Drawer open by default on desktop
  const navigate = useNavigate();
  const location = useLocation();

  const [searchValue, setSearchValue] = useState('');
  const [searchOpen, setSearchOpen] = useState(false);
  const [searchResults, setSearchResults] = useState(null);
  const [searchLoading, setSearchLoading] = useState(false);
  const [searchError, setSearchError] = useState(null);

  // Adjust drawer state based on screen size changes
  useEffect(() => {
    if (!isMobile && !open) { // If desktop and drawer closed, open it
      setOpen(true);
    } else if (isMobile && open) { // If mobile and drawer open, close it
      setOpen(false);
    }
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [isMobile]); // Rerun when isMobile changes

  const handleDrawerToggle = () => {
    setOpen(!open);
  };

  const handleNavigation = (path) => {
    navigate(path);
    if (isMobile) {
      setOpen(false); // Close mobile drawer on navigation
    }
  };

  const performSearch = useCallback(async () => {
    if (searchValue.trim()) {
      setSearchLoading(true);
      setSearchError(null);
      setSearchResults(null);
      setSearchOpen(true);
      try {
        const results = await api.globalSearch(searchValue.trim());
        setSearchResults(results);
      } catch (err) {
        console.error("Search error:", err);
        setSearchError(err.message || 'Error searching. Please try again.');
      } finally {
        setSearchLoading(false);
      }
    }
  }, [searchValue]); // Add dependencies

  const handleSearchInputChange = (e) => setSearchValue(e.target.value);
  
  const handleSearchKeyDown = (e) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      performSearch();
    }
     if (e.key === 'Escape') {
      setSearchOpen(false);
    }
  };
  
  const handleSearchIconClick = () => performSearch();
  const handleCloseModal = () => setSearchOpen(false);

  const handleResultClick = (type, id) => {
    let path = '';
    switch (type) {
      case 'characters': path = `/characters/${id}`; break;
      case 'timeline': path = `/timelines/${id}`; break;
      case 'puzzles': path = `/puzzles/${id}`; break;
      case 'elements': path = `/elements/${id}`; break;
      default: return;
    }
    navigate(path);
    handleCloseModal();
  };

  // Effect for global search hotkey (e.g., Ctrl+K or Cmd+K)
  useEffect(() => {
    const handleKeyDown = (event) => {
      if ((event.metaKey || event.ctrlKey) && event.key === 'k') {
        event.preventDefault();
        // Focus the search input in the AppBar
        const searchInput = document.getElementById('global-search-input');
        if (searchInput) {
          searchInput.focus();
        }
      }
    };
    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, []);


  const drawerContent = (
    <>
      <Toolbar sx={{
        display: 'flex', alignItems: 'center', justifyContent: 'flex-start', // Align title left
        px: [2], minHeight: { xs: 56, sm: 64 } 
      }}>
         <MuiLink component={RouterLink} to="/" sx={{ textDecoration: 'none', color: 'inherit', display: 'flex', alignItems: 'center' }}>
            {/* <img src="/path-to-your-logo.svg" alt="StoryForge Logo" style={{ height: 32, marginRight: 12 }} /> Simple logo placeholder */}
            <Typography variant="h6" component="div" sx={{ fontWeight: 'bold' }}>
              StoryForge
            </Typography>
          </MuiLink>
        {isMobile && open && (
          <IconButton onClick={handleDrawerToggle} aria-label="close drawer" sx={{ ml: 'auto' }}>
            <ChevronLeftIcon />
          </IconButton>
        )}
      </Toolbar>
      <Divider />
      <List sx={{pt:1}}>
        {navItems.map((item) => (
          <ListItem key={item.text} disablePadding sx={{ display: 'block', px: 1, mb: 0.5 }}>
            <Tooltip title={item.text} placement="right" disableHoverListener={open}>
              <ListItemButton
                selected={location.pathname === item.path || (item.path !== '/' && location.pathname.startsWith(item.path))}
                onClick={() => handleNavigation(item.path)}
                sx={{
                  minHeight: 44, // Slightly more compact
                  justifyContent: 'initial', // Always align items left
                  px: 1.5,
                  borderRadius: theme.shape.borderRadius -2, // Consistent rounding
                }}
              >
                <ListItemIcon sx={{
                  minWidth: 0, mr: open ? 2 : 'auto', justifyContent: 'center',
                  color: (location.pathname === item.path || (item.path !== '/' && location.pathname.startsWith(item.path))) ? theme.palette.primary.light : 'text.secondary'
                }}>
                  {item.icon}
                </ListItemIcon>
                <ListItemText primary={item.text} sx={{ opacity: open ? 1 : 0, color: 'text.primary', whiteSpace: 'nowrap' }} />
              </ListItemButton>
            </Tooltip>
          </ListItem>
        ))}
      </List>
    </>
  );

  // Main content area width calculation
  const mainContentWidth = `calc(100% - ${open && !isMobile ? drawerWidth : 0}px)`;
  const mainContentMarginLeft = open && !isMobile ? drawerWidth : 0;

  return (
    <Box sx={{ display: 'flex', minHeight: '100vh', bgcolor: 'background.default' }}>
      <CssBaseline />
      <AppBar
        position="fixed"
        sx={{
          width: { md: mainContentWidth },
          ml: { md: mainContentMarginLeft },
          zIndex: theme.zIndex.drawer + 1,
          transition: theme.transitions.create(['width', 'margin'], {
            easing: theme.transitions.easing.sharp,
            duration: theme.transitions.duration.leavingScreen,
          }),
        }}
      >
        <Toolbar>
          <IconButton
            color="inherit"
            aria-label="open drawer"
            edge="start"
            onClick={handleDrawerToggle}
            sx={{ mr: 2, display: { md: 'none' } }} 
          >
            <MenuIcon />
          </IconButton>
          <Typography variant="h6" noWrap component="div" sx={{ flexGrow: 1, display: { xs: 'none', sm: 'block' } }}>
            {/* Intentionally blank or show current page title here */}
          </Typography>
          <TextField
            id="global-search-input" // ID for focusing
            size="small"
            variant="outlined"
            placeholder="Search (Ctrl+K)"
            value={searchValue}
            onChange={handleSearchInputChange}
            onKeyDown={handleSearchKeyDown}
            aria-label="Global search"
            sx={{
              bgcolor: 'rgba(255,255,255,0.08)', 
              borderRadius: theme.shape.borderRadius -2,
              minWidth: { xs: 150, sm: 220, md: 280 },
              transition: 'background-color 0.3s',
              '&:hover': { bgcolor: 'rgba(255,255,255,0.12)'},
              '& .MuiOutlinedInput-root': {
                '& fieldset': { borderColor: 'rgba(255,255,255,0.23)' },
                '&:hover fieldset': { borderColor: 'rgba(255,255,255,0.5)' },
                '&.Mui-focused fieldset': { borderColor: theme.palette.primary.light, boxShadow: `0 0 0 2px ${theme.palette.primary.main}33` },
              },
            }}
            InputProps={{
              startAdornment: (
                <InputAdornment position="start" sx={{pl:0.5}}>
                  <IconButton onClick={handleSearchIconClick} edge="start" aria-label="perform search" size="small" sx={{color: 'text.secondary'}}>
                    <SearchIcon />
                  </IconButton>
                </InputAdornment>
              ),
            }}
          />
        </Toolbar>
      </AppBar>
      
      <Drawer 
        variant={isMobile ? "temporary" : "persistent"}
        open={open}
        onClose={isMobile ? handleDrawerToggle : undefined} // Close on click away for mobile
        ModalProps={{ keepMounted: true }} // For mobile temporary drawer
        sx={{
          width: drawerWidth,
          flexShrink: 0,
          '& .MuiDrawer-paper': {
            width: drawerWidth,
            boxSizing: 'border-box',
            transition: theme.transitions.create('width', {
              easing: theme.transitions.easing.sharp,
              duration: theme.transitions.duration.enteringScreen,
            }),
            overflowX: 'hidden',
          },
        }}
      >
        {drawerContent}
      </Drawer>

      <Box
        component="main"
        sx={{
          flexGrow: 1,
          p: { xs: 2, sm: 2.5, md: 3 }, // Slightly reduced padding
          width: { md: mainContentWidth }, 
          ml: { md: mainContentMarginLeft }, 
          mt: { xs: '56px', sm: '64px' }, 
          height: `calc(100vh - ${isMobile ? '56px' : '64px'})`, 
          overflowY: 'auto', 
          transition: theme.transitions.create(['width', 'margin-left'], {
            easing: theme.transitions.easing.sharp,
            duration: theme.transitions.duration.enteringScreen,
          }),
        }}
      >
        {children}
      </Box>

      <Modal open={searchOpen} onClose={handleCloseModal} aria-labelledby="search-modal-title">
        <Paper sx={{
          position: 'absolute', top: '20%', left: '50%', // Position higher
          transform: 'translateX(-50%)',
          width: { xs: '90%', sm: 550, md: 650 }, 
          bgcolor: 'background.paper', // Use paper for elevation consistency
          borderRadius: 1.5, // Consistent rounding
          boxShadow: 24, p: { xs: 2, sm: 3 },
          maxHeight: '70vh', overflowY: 'auto',
        }}>
          <Typography variant="h6" component="h2" id="search-modal-title" sx={{ mb: 2 }}>
            Search Results for: <Typography component="span" sx={{fontWeight: 'bold'}}>{searchValue}</Typography>
          </Typography>
          {searchLoading && (
            <Box sx={{ display: 'flex', justifyContent: 'center', my: 3 }}><CircularProgress /></Box>
          )}
          {searchError && <Alert severity="error" sx={{my: 2}}>{searchError}</Alert>}
          
          {!searchLoading && !searchError && searchResults && Object.keys(searchResults).every(key => searchResults[key].length === 0) && (
            <Typography sx={{ my: 3, textAlign: 'center', color: 'text.secondary' }}>
              No results found. Try a different search term.
            </Typography>
          )}

          {!searchLoading && !searchError && searchResults && (
            Object.entries(searchResults).map(([type, items]) => (
              items.length > 0 && (
                <Box key={type} sx={{ mb: 2.5 }}>
                  <Typography variant="overline" sx={{ display:'block', color: 'text.secondary', borderBottom: 1, borderColor: 'divider', pb: 0.5, mb: 1, fontWeight: 'medium' }}>
                    {type} ({items.length})
                  </Typography>
                  <MUIList dense>
                    {items.map((item) => (
                      <MUIListItem
                        button
                        key={`${type}-${item.id}`}
                        onClick={() => handleResultClick(type, item.id)}
                        sx={{ borderRadius: 1, '&:hover': { bgcolor: 'action.hover' }, mb: 0.5 }}
                      >
                        <ListItemIcon sx={{minWidth: 36, mr:0.5}}>
                           {getIconForType(type) || <Box sx={{width: 20}} />}
                        </ListItemIcon>
                        <MUIListItemText 
                          primaryTypographyProps={{ sx: {fontWeight: 500} }}
                          primary={item.name || item.puzzle || item.description || 'Unknown Item'}
                          secondary={`ID: ${item.id}`}
                        />
                      </MUIListItem>
                    ))}
                  </MUIList>
                </Box>
              )
            ))
          )}
        </Paper>
      </Modal>
    </Box>
  );
}
```
---
--- FILE: storyforge/frontend/src/components/RelationshipMapper/layoutUtils.js ---
```javascript
/**
 * Layout utilities for arranging nodes in the relationship mapper.
 * This version attempts a more structured layout, grouping by type
 * and arranging groups in sectors, then nodes within groups radially or in a list.
 */

const GROUP_SETTINGS = {
  Character: { angle: -Math.PI / 2, order: 1, radiusFactor: 1.0 }, // Top
  Puzzle: { angle: 0, order: 2, radiusFactor: 1.1 },              // Right
  Element: { angle: Math.PI / 2, order: 3, radiusFactor: 1.0 },   // Bottom
  Timeline: { angle: Math.PI, order: 4, radiusFactor: 1.2 },     // Left
  Unknown: { angle: Math.PI * 1.5, order: 5, radiusFactor: 0.9}  // Default for other types
};

const DEFAULT_GROUP_SETTING = { angle: Math.PI * 1.5, order: 5, radiusFactor: 0.9 };


export const getLayoutedElements = (nodes, edges, options = {}) => {
  if (!nodes || nodes.length === 0) {
    return { nodes: [], edges: [] };
  }

  try {
    const centerNode = nodes.find(node => node.data.isCenter);
    if (!centerNode) {
      console.warn('No center node found for layout.');
      // Fallback: simple grid or return as is
      nodes.forEach((n, i) => {
        if (!n.position) n.position = { x: (i % 5) * 200, y: Math.floor(i / 5) * 150 };
      });
      return { nodes, edges };
    }

    const centerPosition = { x: 0, y: 0 };
    centerNode.position = { ...centerPosition };

    const nodesToArrange = nodes.filter(node => node.id !== centerNode.id);

    if (nodesToArrange.length === 0) {
      return { nodes, edges };
    }

    const defaultOptions = {
      baseRadius: 280,         // Base distance from center for first node in a group
      minRadiusBetweenNodes: 120, // Min distance between nodes in the same radial group
      listSpacing: 90,         // Vertical spacing if a group is laid out as a list
      maxNodesRadial: 5,       // Max nodes in a group before switching to list layout for that group
      nodeWidth: 180,          // Approximate width for spacing
      nodeHeight: 80,          // Approximate height for spacing
    };
    const config = { ...defaultOptions, ...options };

    // Group nodes by their type
    const nodesByType = {};
    nodesToArrange.forEach(node => {
      const type = node.data.type || 'Unknown';
      if (!nodesByType[type]) {
        nodesByType[type] = [];
      }
      nodesByType[type].push(node);
    });

    // Sort group keys by predefined order for consistent layout
    const sortedGroupKeys = Object.keys(nodesByType).sort((a, b) => {
      const orderA = (GROUP_SETTINGS[a] || DEFAULT_GROUP_SETTING).order;
      const orderB = (GROUP_SETTINGS[b] || DEFAULT_GROUP_SETTING).order;
      return orderA - orderB;
    });
    
    sortedGroupKeys.forEach(typeKey => {
      const groupNodes = nodesByType[typeKey];
      const numNodesInGroup = groupNodes.length;
      const groupConfig = GROUP_SETTINGS[typeKey] || DEFAULT_GROUP_SETTING;
      const groupBaseAngle = groupConfig.angle;
      const groupRadius = config.baseRadius * groupConfig.radiusFactor;

      if (numNodesInGroup === 0) return;

      // Decide layout strategy for the group (radial or list)
      const useListLayout = numNodesInGroup > config.maxNodesRadial;

      if (useListLayout) {
        // List layout for this group (e.g., vertically along the group's base angle)
        const listDirectionX = Math.cos(groupBaseAngle);
        const listDirectionY = Math.sin(groupBaseAngle);
        // Offset start to center the list somewhat
        const listStartOffset = - (numNodesInGroup -1) * config.listSpacing / 2;

        groupNodes.forEach((node, index) => {
          const L = listStartOffset + index * config.listSpacing;
          node.position = {
            x: centerPosition.x + groupRadius * Math.cos(groupBaseAngle) + L * (Math.abs(listDirectionX) < 0.1 ? 0 : (listDirectionX > 0 ? 0.3 : -0.3)), // Spread list perpendicular to axis
            y: centerPosition.y + groupRadius * Math.sin(groupBaseAngle) + L * (Math.abs(listDirectionY) < 0.1 ? 0 : (listDirectionY > 0 ? 0.3 : -0.3)),
          };
           // A bit hacky to spread perpendicular to the main axis of the group angle
           if (Math.abs(listDirectionX) > Math.abs(listDirectionY)) { // Primarily horizontal group
             node.position.y += L;
             node.position.x += (index % 2 === 0 ? -1 : 1) * config.nodeWidth * 0.2; // Stagger
           } else { // Primarily vertical group
             node.position.x += L;
             node.position.y += (index % 2 === 0 ? -1 : 1) * config.nodeHeight * 0.2; // Stagger
           }
        });

      } else {
        // Radial layout for this group (fan out from groupBaseAngle)
        const angularSpreadForGroup = Math.min(Math.PI / 3, numNodesInGroup * Math.atan2(config.nodeWidth * 1.2, groupRadius)); // Max PI/3 spread
        const angleStep = numNodesInGroup > 1 ? angularSpreadForGroup / (numNodesInGroup - 1) : 0;
        const startAngle = groupBaseAngle - (numNodesInGroup > 1 ? angularSpreadForGroup / 2 : 0);

        groupNodes.forEach((node, index) => {
          const angle = startAngle + index * angleStep;
          // Slightly increase radius for subsequent nodes in a radial fan to avoid overlap
          const R = groupRadius + (index * 20); // Small radial increment
          node.position = {
            x: centerPosition.x + R * Math.cos(angle),
            y: centerPosition.y + R * Math.sin(angle),
          };
        });
      }
    });
    
    return { nodes, edges };

  } catch (error) {
    console.error('Error in getLayoutedElements:', error);
    return { nodes: nodes || [], edges: edges || [] };
  }
};
```
---
--- FILE: storyforge/frontend/src/components/RelationshipMapper/RelationshipMapper.jsx ---
```jsx
import { useState, useCallback, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import PropTypes from 'prop-types';
import {
  ReactFlow, Background, Controls, MiniMap, useNodesState, useEdgesState, MarkerType, useReactFlow,
} from '@xyflow/react';
import { Box, Typography, Paper, CircularProgress, Alert, Button, IconButton, Tooltip } from '@mui/material';
import ZoomInIcon from '@mui/icons-material/ZoomIn';
import ZoomOutIcon from '@mui/icons-material/ZoomOut';
import FitScreenIcon from '@mui/icons-material/FitScreen';
import FilterListIcon from '@mui/icons-material/FilterList'; // For future filtering

import EntityNode from './EntityNode';
import FallbackGraph from './FallbackGraph';
import { getLayoutedElements } from './layoutUtils';

const RelationshipMapper = ({ 
  title, entityType, entityId, entityName, relationshipData, isLoading, error,
}) => {
  const navigate = useNavigate();
  const [nodes, setNodes, onNodesChange] = useNodesState([]);
  const [edges, setEdges, onEdgesChange] = useEdgesState([]);
  const [renderError, setRenderError] = useState(null);
  const reactFlowInstance = useReactFlow(); // Get instance via hook

  const nodeTypes = { entityNode: EntityNode };

  useEffect(() => {
    if (isLoading || !relationshipData || !entityId) return;
    
    setRenderError(null); // Clear previous errors on new data
    try {
      const { nodes: newNodes, edges: newEdges } = transformDataToGraphElements(
        entityType, entityId, entityName, relationshipData
      );
      
      if (newNodes.length > 0) {
        const { nodes: layoutedNodes, edges: layoutedEdges } = getLayoutedElements(newNodes, newEdges);
        setNodes(layoutedNodes);
        setEdges(layoutedEdges);
        // Fit view after nodes are set and layout applied
        setTimeout(() => reactFlowInstance.fitView({ padding: 0.2, duration: 400 }), 100);

      } else {
        setNodes([]);
        setEdges([]);
      }
    } catch (err) {
      console.error('Error transforming data for RelationshipMapper:', err);
      setRenderError(err.message || 'Failed to process relationship data.');
      setNodes([]); 
      setEdges([]);
    }
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [relationshipData, entityType, entityId, entityName, isLoading, setNodes, setEdges]); // reactFlowInstance not needed here

  const onNodeClick = useCallback((event, node) => {
    if (node.data?.route && node.id !== entityId) { 
      navigate(node.data.route);
    }
  }, [navigate, entityId]);

  const onReactFlowError = useCallback((errCode, errMessage) => {
    console.error('ReactFlow render error:', errCode, errMessage);
    setRenderError(`ReactFlow Error (${errCode}): ${errMessage}`);
  }, []);

  const onFitView = () => reactFlowInstance?.fitView({ padding: 0.2, duration: 300 });
  const onZoomIn = () => reactFlowInstance?.zoomIn({ duration: 300 });
  const onZoomOut = () => reactFlowInstance?.zoomOut({ duration: 300 });

  if (isLoading) {
    return (
      <Paper sx={{ p: 2, height: '500px', display: 'flex', justifyContent: 'center', alignItems: 'center' }} elevation={1}>
        <Box textAlign="center">
          <CircularProgress sx={{mb: 1}} />
          <Typography>Loading Relationship Map...</Typography>
        </Box>
      </Paper>
    );
  }

  if (error) {
    return (
      <Paper sx={{ p: 2, height: '500px' }} elevation={1}>
        <Alert severity="error">
          Error loading relationship data: {error.message}
        </Alert>
      </Paper>
    );
  }
  
  if (renderError) {
     return (
      <Paper sx={{ p: 2, height: '500px', overflowY: 'auto' }} elevation={1}>
        <Alert severity="error" sx={{mb: 2}}>
          Could not render relationship map: {renderError}
        </Alert>
        <Typography variant="body2">Attempting to display fallback data:</Typography>
        <FallbackGraph 
          entityType={entityType}
          entityName={entityName}
          relationshipData={relationshipData}
        />
      </Paper>
    );
  }

  // Check after error handling, if there are no nodes to display (e.g. entity with no relations)
  if (!relationshipData || nodes.length === 0 || (nodes.length === 1 && edges.length === 0 && nodes[0].id === entityId)) {
    return (
      <Paper sx={{ p: 2, height: '500px', display: 'flex', flexDirection: 'column', justifyContent: 'center', alignItems: 'center' }} elevation={1}>
         <Typography variant="h6" sx={{ mb: 1, textAlign: 'center', color: 'text.secondary' }}>
          {title || 'Relationship Map'}
        </Typography>
        <EventIcon sx={{ fontSize: 48, color: 'text.disabled', my: 2 }} /> {/* Placeholder icon for no relations */}
        <Typography variant="body1" color="text.secondary" sx={{textAlign: 'center'}}>
          No direct relationships found for {entityName} to visualize in the map.
        </Typography>
        <Typography variant="caption" color="text.disabled" sx={{mt:0.5, textAlign: 'center'}}>
          Associated data might still be available in the tabs below.
        </Typography>
      </Paper>
    );
  }

  return (
    <Paper sx={{ p: 2, height: '500px', display: 'flex', flexDirection: 'column' }} elevation={1}>
      <Box sx={{display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb:1.5}}>
        <Typography variant="h6">
          {title || 'Relationship Map'}
        </Typography>
        <Box>
          <Tooltip title="Zoom In"><IconButton onClick={onZoomIn} size="small" aria-label="zoom in"><ZoomInIcon /></IconButton></Tooltip>
          <Tooltip title="Zoom Out"><IconButton onClick={onZoomOut} size="small" aria-label="zoom out"><ZoomOutIcon /></IconButton></Tooltip>
          <Tooltip title="Fit View"><IconButton onClick={onFitView} size="small" aria-label="fit view"><FitScreenIcon /></IconButton></Tooltip>
          {/* <Tooltip title="Filter Connections (Future)"><span><IconButton size="small" aria-label="filter connections" disabled><FilterListIcon /></IconButton></span></Tooltip> */}
        </Box>
      </Box>
      <Box sx={{ flexGrow: 1, width: '100%', position: 'relative', border: 1, borderColor: 'divider', borderRadius: 1, overflow: 'hidden' }}>
        <ReactFlow
          nodes={nodes}
          edges={edges}
          onNodesChange={onNodesChange}
          onEdgesChange={onEdgesChange}
          onNodeClick={onNodeClick}
          onError={onReactFlowError}
          // onInit={setReactFlowInstance} // Not needed with useReactFlow hook
          nodeTypes={nodeTypes}
          fitView
          fitViewOptions={{ padding: 0.25, duration: 0 }} 
          minZoom={0.1} 
          maxZoom={3}
          defaultViewport={{ x: 0, y: 0, zoom: 0.8 }} // Start slightly zoomed out
          proOptions={{ hideAttribution: true }} 
          elevateEdgesOnSelect
        >
          <Background gap={30} size={1.5} color="#2a2a2a" variant="dots" />
          <Controls showInteractive={false} position="bottom-left"/> 
          <MiniMap 
            nodeColor={(n) => n.data?.isCenter ? '#8364e2' : EntityNode.propTypes.data.color || '#555'} // Use node color from EntityNode if possible
            nodeStrokeWidth={2} 
            pannable 
            zoomable
            style={{backgroundColor: '#101010', border: '1px solid #333'}}
            maskColor="rgba(30,30,30,0.6)"
          />
        </ReactFlow>
      </Box>
    </Paper>
  );
};

// transformDataToGraphElements function remains largely the same as previous good version, 
// but ensure edge styling is robust.
function transformDataToGraphElements(entityType, entityId, entityName, data) {
  if (!entityId || !data) {
    console.warn("Missing entityId or data for graph transformation.");
    return { nodes: [], edges: [] };
  }

  const centerNode = {
    id: entityId,
    position: { x: 0, y: 0 }, 
    type: 'entityNode',
    data: {
      label: entityName || data.name || data.description || data.puzzle || 'Central Entity',
      type: entityType,
      id: entityId,
      isCenter: true,
    },
    style: { zIndex: 100 } // Ensure center node is on top
  };
  
  const nodes = [centerNode];
  const edges = [];
  const addedNodeIds = new Set([entityId]); 
  
  const addRelatedEntities = (relatedEntities, relationType, relationLabel, targetEntityTypeSingular) => {
    if (!relatedEntities || !Array.isArray(relatedEntities) || relatedEntities.length === 0) return;
    
    relatedEntities.forEach((entity) => {
      if (!entity || !entity.id) {
        console.warn(`Missing entity id in ${targetEntityTypeSingular} relation:`, entity);
        return;
      }
      
      const nodeId = `${targetEntityTypeSingular}-${entity.id}`; // Prefix with type for uniqueness
      if (!addedNodeIds.has(nodeId)) {
        nodes.push({
          id: nodeId,
          type: 'entityNode',
          data: {
            label: entity.name || entity.description || entity.puzzle || `Unnamed ${targetEntityTypeSingular}`,
            type: targetEntityTypeSingular, 
            id: entity.id,
            route: `/${targetEntityTypeSingular.toLowerCase()}s/${entity.id}`, // Ensure plural for routes
            properties: entity, 
          },
          position: { x: 0, y: 0 }, 
        });
        addedNodeIds.add(nodeId);
      }
      
      edges.push({
        id: `edge-${entityId}-${nodeId}-${relationLabel.replace(/\s+/g, '')}`, 
        source: entityId,
        target: nodeId,
        label: relationLabel,
        type: 'smoothstep', 
        markerEnd: { type: MarkerType.ArrowClosed, width: 15, height: 15, color: '#777' },
        style: { strokeWidth: 1.5, stroke: '#777' },
        labelStyle: { fill: '#ddd', fontWeight: 400, fontSize: '10px' },
        labelBgPadding: [3, 5],
        labelBgBorderRadius: 3,
        labelBgStyle: { fill: 'rgba(20,20,20,0.7)'},
        animated: false, // Keep false unless specifically needed for an interaction
        data: { relationType },
      });
    });
  };
  
  // Switch cases for adding entities remain the same as previous good version
    switch (entityType) {
    case 'Character':
      addRelatedEntities(data.ownedElements, 'owns', 'Owns', 'Element');
      addRelatedEntities(data.associatedElements, 'associated_with', 'Associated', 'Element');
      addRelatedEntities(data.events, 'participates_in', 'Participates', 'Timeline');
      addRelatedEntities(data.puzzles, 'involved_in', 'Involved In', 'Puzzle'); // Changed label slightly
      break;
      
    case 'Element':
      if (data.owner) addRelatedEntities([data.owner], 'owned_by', 'Owned By', 'Character');
      addRelatedEntities(data.associatedCharacters, 'associated_with', 'Associated', 'Character');
      addRelatedEntities(data.timelineEvents, 'appears_in', 'Appears In', 'Timeline');
      addRelatedEntities(data.requiredForPuzzle, 'required_for', 'Required For', 'Puzzle');
      addRelatedEntities(data.rewardedByPuzzle, 'rewarded_by', 'Rewarded By', 'Puzzle');
      if (data.containerPuzzle) addRelatedEntities([data.containerPuzzle], 'locked_by', 'Container Puzzle', 'Puzzle'); // Changed label
      if (data.container) addRelatedEntities([data.container], 'inside', 'Inside', 'Element');
      addRelatedEntities(data.contents, 'contains', 'Contains', 'Element');
      break;
      
    case 'Puzzle':
      if (data.owner) addRelatedEntities([data.owner], 'owned_by', 'Owned By', 'Character');
      if (data.lockedItem) addRelatedEntities([data.lockedItem], 'locks', 'Locks Item', 'Element'); // Changed label
      addRelatedEntities(data.puzzleElements, 'requires', 'Requires', 'Element');
      addRelatedEntities(data.rewards, 'rewards', 'Rewards', 'Element');
      if (data.parentItem) addRelatedEntities([data.parentItem], 'sub_of', 'Sub-Puzzle of', 'Puzzle');
      addRelatedEntities(data.subPuzzles, 'has_sub', 'Has Sub-Puzzle', 'Puzzle');
      break;
      
    case 'Timeline': 
      addRelatedEntities(data.charactersInvolved, 'involves', 'Involves', 'Character');
      addRelatedEntities(data.memoryEvidence, 'evidenced_by', 'Evidenced By', 'Element');
      break;
      
    default:
      console.warn("Unknown entityType for relationship mapping:", entityType);
      break;
  }
  
  return { nodes, edges };
}

RelationshipMapper.propTypes = {
  title: PropTypes.string,
  entityType: PropTypes.oneOf(['Character', 'Element', 'Puzzle', 'Timeline']).isRequired,
  entityId: PropTypes.string.isRequired,
  entityName: PropTypes.string,
  relationshipData: PropTypes.object,
  isLoading: PropTypes.bool,
  error: PropTypes.object,
};

export default RelationshipMapper;
```
---
--- FILE: storyforge/frontend/src/components/RelationshipMapper/EntityNode.jsx ---
```jsx
import React, { memo } from 'react';
import PropTypes from 'prop-types';
import { Handle, Position } from '@xyflow/react';
import { Paper, Typography, Box, Chip, Tooltip } from '@mui/material';
import PersonIcon from '@mui/icons-material/Person';
import InventoryIcon from '@mui/icons-material/Inventory';
import EventIcon from '@mui/icons-material/Event';
import ExtensionIcon from '@mui/icons-material/Extension';
import HelpOutlineIcon from '@mui/icons-material/HelpOutline';

const getEntityPresentation = (type, isCenter = false) => {
  let color = '#78909c'; // Default Blue Grey 400
  let icon = <HelpOutlineIcon fontSize="inherit" />;
  let contrastColor = 'rgba(0,0,0,0.87)'; // For chips on light backgrounds

  if (isCenter) {
    color = '#673ab7'; // Deep Purple 500 for center node
    contrastColor = '#fff';
  }
  
  switch (type) {
    case 'Character':
      color = isCenter ? color : '#3f51b5'; // Indigo 500
      icon = <PersonIcon fontSize="inherit" />;
      contrastColor = '#fff';
      break;
    case 'Element':
      color = isCenter ? color : '#00897b'; // Teal 600
      icon = <InventoryIcon fontSize="inherit" />;
      contrastColor = '#fff';
      break;
    case 'Puzzle':
      color = isCenter ? color : '#f57c00'; // Orange 700
      icon = <ExtensionIcon fontSize="inherit" />;
      contrastColor = '#fff';
      break;
    case 'Timeline': 
      color = isCenter ? color : '#d81b60'; // Pink 600
      icon = <EventIcon fontSize="inherit" />;
      contrastColor = '#fff';
      break;
  }
  return { color, icon, contrastColor };
};

const EntityNode = ({ data, isConnectable, selected }) => { // `selected` prop from React Flow
  const { label, type, isCenter = false, properties, id } = data;
  const { color: entityColor, icon: entityIcon, contrastColor } = getEntityPresentation(type, isCenter);
  
  const getSecondaryInfo = () => {
    if (!properties) return null;
    switch (type) {
      case 'Character': return properties.tier || properties.type;
      case 'Element': return properties.basicType;
      case 'Puzzle': return properties.timing;
      case 'Timeline': return properties.date ? new Date(properties.date).toLocaleDateString() : null;
      default: return null;
    }
  };
  
  const secondaryInfo = getSecondaryInfo();
  const nodeLabel = label || type || id || 'Unknown';
  const nodeAriaLabel = `${isCenter ? 'Central Entity: ' : ''}${type}: ${nodeLabel}${secondaryInfo ? `, ${secondaryInfo}` : ''}`;

  return (
    <Paper
      elevation={isCenter ? 6 : (selected ? 8 : 3)} // Higher elevation if selected
      sx={{
        p: isCenter ? 1.5 : 1.25, 
        borderRadius: 1.5, 
        width: isCenter ? 190 : 160, 
        minHeight: isCenter ? 60 : 50,
        border: `2px solid ${selected ? entityColor : entityColor + 'aa'}`, // Brighter border if selected
        bgcolor: isCenter ? `${entityColor}4D` : (selected ? 'background.paper' : `${entityColor}26`), // Slightly different bg if selected vs default
        transition: 'all 0.15s ease-in-out, border-color 0.15s, background-color 0.15s',
        transform: selected ? 'scale(1.05)' : 'scale(1)',
        '&:hover': {
          borderColor: entityColor,
          bgcolor: isCenter ? `${entityColor}66` : 'background.paper', // Hover to paper bg for non-center
          transform: 'scale(1.03)',
        },
        display: 'flex', flexDirection: 'column', justifyContent: 'center',
        textAlign: 'center', cursor: 'pointer',
        boxShadow: selected ? (theme) => theme.shadows[6] : undefined,
      }}
      aria-label={nodeAriaLabel} role="button" tabIndex={0}
    >
      <Handle type="target" position={Position.Top} isConnectable={isConnectable} style={{ background: entityColor, width: 6, height: 6, opacity: 0.7 }} />
      
      <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'center', mb: 0.25, minHeight: 24 /* Ensure space for icon+text */ }}>
        <Box sx={{ mr: 0.75, color: entityColor, fontSize: isCenter ? '1.1rem' : '1rem', lineHeight: 1 }}>
          {React.cloneElement(entityIcon, { fontSize: 'inherit' })}
        </Box>
        <Tooltip title={nodeLabel} placement="top" arrow disableInteractive>
          <Typography 
            variant={isCenter ? "body1" : "body2"}
            sx={{ 
              fontWeight: isCenter ? 'bold' : 500,
              color: 'text.primary',
              overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap',
              maxWidth: '100%',
            }}
          >
            {nodeLabel}
          </Typography>
        </Tooltip>
      </Box>
      
      {secondaryInfo && (
        <Tooltip title={secondaryInfo} placement="bottom" arrow disableInteractive>
          <Chip 
            label={secondaryInfo} 
            size="small" 
            sx={{ 
              bgcolor: `${entityColor}33`, 
              color: entityColor, // Use entity color for text for better contrast on light chip
              // If chip bg is dark, use contrastColor for text:
              // bgcolor: entityColor, color: contrastColor,
              fontSize: '0.65rem', fontWeight: 500,
              height: 18, maxWidth: '90%', mx: 'auto', mt: 0.25,
              '& .MuiChip-label': { overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap' }
            }}
          />
        </Tooltip>
      )}
      
      <Handle type="source" position={Position.Bottom} isConnectable={isConnectable} style={{ background: entityColor, width: 6, height: 6, opacity: 0.7 }} />
    </Paper>
  );
};

EntityNode.propTypes = {
  data: PropTypes.shape({
    id: PropTypes.string.isRequired,
    label: PropTypes.string,
    type: PropTypes.string.isRequired,
    isCenter: PropTypes.bool,
    properties: PropTypes.object,
  }).isRequired,
  isConnectable: PropTypes.bool,
  selected: PropTypes.bool, // Added selected prop
};

export default memo(EntityNode);
```
---
--- FILE: storyforge/frontend/src/pages/CharacterDetail.jsx ---
```jsx
import { useState } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { useQuery, useQueryClient, useIsFetching } from 'react-query';
import {
  Box, Grid, Paper, Typography, Chip, Button, CircularProgress, Divider,
  List, ListItem, ListItemText, Alert, Tab, Tabs, Tooltip, IconButton,
} from '@mui/material';
import ArrowBackIcon from '@mui/icons-material/ArrowBack';
import EditIcon from '@mui/icons-material/Edit';
import RefreshIcon from '@mui/icons-material/Refresh';
import VisibilityIcon from '@mui/icons-material/Visibility';
import VisibilityOffIcon from '@mui/icons-material/VisibilityOff';
import PersonIcon from '@mui/icons-material/Person';
import SmartToyIcon from '@mui/icons-material/SmartToy';
import PageHeader from '../components/PageHeader';
import RelationshipMapper from '../components/RelationshipMapper';
import { api } from '../services/api';
import { Link as RouterLink } from 'react-router-dom';

const DetailItem = ({ label, value, chipColor, chipIcon, fullWidth = false, children }) => (
  <Grid item xs={12} sm={fullWidth ? 12 : 6} md={fullWidth ? 12 : 6}> {/* Adjusted sm breakpoint */}
    <Typography variant="subtitle2" color="text.secondary" gutterBottom>
      {label}
    </Typography>
    {children ? children : (
      chipColor && value ? (
        <Chip label={value} color={chipColor} icon={chipIcon} variant="outlined" />
      ) : (
        <Typography variant="body1" sx={{ whiteSpace: 'pre-wrap' }}>
          {value || <Typography component="span" sx={{ fontStyle: 'italic', color: 'text.disabled' }}>N/A</Typography>}
        </Typography>
      )
    )}
  </Grid>
);

function CharacterDetail() {
  const { id } = useParams();
  const navigate = useNavigate();
  const queryClient = useQueryClient();
  const [activeTab, setActiveTab] = useState(0);
  const [showMapper, setShowMapper] = useState(true); // Show mapper by default
  
  const queryKey = ['character', id];
  const { data: character, isLoading: characterIsLoading, error, refetch } = useQuery(
    queryKey,
    () => api.getCharacterById(id),
    { enabled: !!id }
  );
  // Global isFetching for any query with this key, good for refresh button state
  const isFetchingCharacter = useIsFetching(queryKey) > 0; 
  
  const handleTabChange = (event, newValue) => setActiveTab(newValue);
  const handleBack = () => navigate('/characters');
  const handleEdit = () => alert('Character editing will be available in Phase 3.');
  const handleRefresh = () => {
    // Invalidate and refetch the current character data
    queryClient.invalidateQueries(queryKey); 
    // No need to call refetch() explicitly if using invalidateQueries with active query
  };

  if (characterIsLoading && !character) { // Show initial loading spinner
    return (
      <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', p: 4, height: 'calc(100vh - 150px)' }}>
        <CircularProgress size={50} /> <Typography sx={{ml:2}}>Loading Character Details...</Typography>
      </Box>
    );
  }
  
  if (error) {
    return (
      <Paper sx={{ p: 3, m:2 }} elevation={3}>
        <Alert severity="error" action={
          <Button color="inherit" size="small" onClick={handleRefresh}>Retry</Button>
        }>
          Error loading character: {error.message || 'An unknown error occurred.'}
        </Alert>
        <Button startIcon={<ArrowBackIcon />} onClick={handleBack} sx={{ mt: 2 }}>
          Back to Characters
        </Button>
      </Paper>
    );
  }
  
  if (!character) { // Should be caught by isLoading, but as a safeguard
    return (
      <Paper sx={{ p: 3, m:2 }} elevation={3}>
        <Alert severity="warning">Character data not available.</Alert>
        <Button startIcon={<ArrowBackIcon />} onClick={handleBack} sx={{ mt: 2 }}>
          Back to Characters
        </Button>
      </Paper>
    );
  }
  
  const pageActions = (
    <Box sx={{ display: 'flex', gap: 1, alignItems: 'center' }}>
       <Tooltip title={isFetchingCharacter ? "Refreshing..." : "Refresh Data"}>
        <span> {/* Span for disabled button tooltip */}
          <IconButton onClick={handleRefresh} disabled={isFetchingCharacter} aria-label="refresh character data">
            <RefreshIcon />
          </IconButton>
        </span>
      </Tooltip>
      <Tooltip title={showMapper ? "Hide Relationship Map" : "Show Relationship Map"}>
        <IconButton onClick={() => setShowMapper(prev => !prev)} aria-label="toggle relationship map" color={showMapper ? "primary" : "default"}>
          {showMapper ? <VisibilityOffIcon /> : <VisibilityIcon />}
        </IconButton>
      </Tooltip>
      <Tooltip title="Edit character (Phase 3)">
        <Button variant="contained" startIcon={<EditIcon />} onClick={handleEdit} size="medium">
          Edit
        </Button>
      </Tooltip>
    </Box>
  );

  return (
    <Box sx={{ maxWidth: 1400, mx: 'auto' }}> {/* Max width for the whole page content */}
      <PageHeader
        title={character.name}
        breadcrumbs={[
          { name: 'Characters', path: '/characters' },
          { name: character.name },
        ]}
        action={pageActions}
      />
      
      <Grid container spacing={2.5}> {/* Reduced spacing */}
        {/* Main Details Column */}
        <Grid item xs={12} md={showMapper ? 7.5 : 12} lg={showMapper ? 8 : 12}>
          <Paper sx={{ p: {xs:2, sm:2.5} }} elevation={1}> {/* Subtle elevation */}
            <Typography variant="h5" gutterBottom sx={{mb:2, fontWeight: 500}}>Character Profile</Typography>
            <Grid container spacing={2}> {/* Spacing for items within profile */}
              <DetailItem label="Type" value={character.type} 
                chipColor={character.type === 'Player' ? 'primary' : 'secondary'}
                chipIcon={character.type === 'Player' ? <PersonIcon /> : <SmartToyIcon />}
              />
              <DetailItem label="Tier" value={character.tier} 
                chipColor={
                  character.tier === 'Core' ? 'success' : 
                  character.tier === 'Secondary' ? 'info' : 'default'
                }
              />
              <DetailItem label="Connections (Count)" value={character.connections?.toString()} />
              <DetailItem label="Primary Action" value={character.primaryAction} />
              
              <DetailItem label="Character Logline" value={character.logline} fullWidth />
              
              {character.overview && (
                <Grid item xs={12} sx={{mt:1}}>
                  <Divider sx={{ my: 1.5 }}><Chip label="Overview & Relationships" size="small" variant="outlined"/></Divider>
                  <Box sx={{ maxHeight: 200, overflowY: 'auto', p:1.5, bgcolor: 'action.hover', borderRadius:1, whiteSpace: 'pre-wrap' }}>
                    <Typography variant="body1">{character.overview}</Typography>
                  </Box>
                </Grid>
              )}
              
              {character.emotion && (
                <Grid item xs={12} sx={{mt:1}}>
                   <Divider sx={{ my: 1.5 }}><Chip label="Emotions" size="small" variant="outlined"/></Divider>
                  <Typography variant="subtitle2" color="text.secondary" gutterBottom>
                    Emotion towards CEO & Others
                  </Typography>
                  <Typography variant="body1" sx={{ whiteSpace: 'pre-wrap' }}>{character.emotion}</Typography>
                </Grid>
              )}
            </Grid>
          </Paper>
        
          <Paper sx={{ mt: 2.5, p:0 }} elevation={1}>
            <Tabs value={activeTab} onChange={handleTabChange} variant="scrollable" scrollButtons="auto" allowScrollButtonsMobile indicatorColor="primary" textColor="primary">
              <Tab label={`Owned Elements (${character.ownedElements?.length || 0})`} />
              <Tab label={`Associated Elements (${character.associatedElements?.length || 0})`} />
              <Tab label={`Timeline Events (${character.events?.length || 0})`} />
              <Tab label={`Puzzles (${character.puzzles?.length || 0})`} />
            </Tabs>
            
            <Box sx={{ p: {xs:1.5, sm:2}, minHeight: 180, maxHeight: 300, overflowY: 'auto' }}>
              {/* Tab Content - using a helper function for brevity */}
              {renderTabContent(activeTab, character, navigate)}
            </Box>
          </Paper>
        </Grid>
        
        {showMapper && (
          <Grid item xs={12} md={4.5} lg={4}> 
            <RelationshipMapper
              title={`${character.name}'s Map`} // Shorter title
              entityType="Character"
              entityId={id}
              entityName={character.name}
              relationshipData={character} 
              isLoading={isFetchingCharacter} 
            />
          </Grid>
        )}
      </Grid>
      
      <Box sx={{ mt: 3, mb: 2 }}>
        <Button startIcon={<ArrowBackIcon />} onClick={handleBack}>
          Back to All Characters
        </Button>
      </Box>
    </Box>
  );
}

// Helper function for tab content to keep main component cleaner
const renderTabContent = (activeTab, character, navigate) => {
  const renderList = (items, type) => {
    if (!items || items.length === 0) {
      return <Typography color="text.secondary" sx={{textAlign:'center', pt:3, fontStyle: 'italic'}}>No {type.toLowerCase()} found.</Typography>;
    }
    return (
      <List dense>
        {items.map(item => {
          let path, primaryText, secondaryText;
          switch(type) {
            case 'Elements':
              path = `/elements/${item.id}`;
              primaryText = item.name || item.id;
              secondaryText = `Type: ${item.basicType || 'Unknown'}`;
              break;
            case 'Timeline Events':
              path = `/timelines/${item.id}`;
              primaryText = item.name || item.description || item.id;
              secondaryText = item.date ? `Date: ${new Date(item.date).toLocaleDateString()}`: 'No date';
              break;
            case 'Puzzles':
              path = `/puzzles/${item.id}`;
              primaryText = item.name || item.puzzle || item.id;
              secondaryText = `Timing: ${item.timing || 'N/A'}`;
              break;
            default: return null;
          }
          return (
            <ListItem key={item.id} button component={RouterLink} to={path} sx={{borderRadius:1, '&:hover': {bgcolor: 'action.selected'}}}>
              <ListItemText primary={primaryText} secondary={secondaryText} />
            </ListItem>
          );
        })}
      </List>
    );
  };

  switch(activeTab) {
    case 0: return renderList(character.ownedElements, 'Elements');
    case 1: return renderList(character.associatedElements, 'Elements');
    case 2: return renderList(character.events, 'Timeline Events');
    case 3: return renderList(character.puzzles, 'Puzzles');
    default: return null;
  }
};

export default CharacterDetail;
```
---

**Summary of Key Changes in this Iteration:**

1.  **Theme (`theme.js`):**
    *   Adjusted background colors (`default` and `paper`) for slightly more contrast.
    *   Tweaked text colors for better brightness.
    *   Made dividers more visible.
    *   Refined typography for `subtitle2` (field labels) to be smaller and `h4` (PageHeader title) to be bolder. `body1` slightly smaller.
    *   Adjusted default `borderRadius` for components.
    *   Subtle shadow added to `AppBar`.
    *   Drawer background slightly darker.
    *   More prominent selected state for `ListItemButton` with a left border.
2.  **Layout (`AppLayout.jsx`):**
    *   Drawer width back to 240px.
    *   Improved drawer header and item styling for compactness and clarity.
    *   Adjusted `mainContentWidth` and `mainContentMarginLeft` to correctly account for drawer state *only on non-mobile screens*. This should help with the sidebar gap issue.
    *   Enhanced search bar styling and added `Ctrl+K` / `Cmd+K` hotkey to focus it.
    *   Improved search modal styling and positioning.
3.  **Relationship Mapper:**
    *   **`layoutUtils.js`:** Significantly refactored to try a sector-based layout. Nodes are grouped by type, and each type is assigned a general angular sector. Within that sector, nodes are either fanned out radially (for small groups) or arranged in a list-like fashion (for larger groups). This is a heuristic approach and may still need tweaking for very specific graph structures, but it's an attempt to move away from pure radial density.
    *   **`RelationshipMapper.jsx`:**
        *   Uses `useReactFlow` hook for instance access.
        *   Improved empty/error states.
        *   Slightly different default zoom.
        *   Enhanced MiniMap and Background styling.
        *   Better edge styling (thinner, slightly muted color, smaller arrow).
    *   **`EntityNode.jsx`:**
        *   Nodes are slightly smaller and more compact.
        *   Border and background change more significantly when `selected`.
        *   Refined chip styling for secondary info.
        *   Improved color palette for entity types.
4.  **`CharacterDetail.jsx`:**
    *   Added a `maxWidth` to the main content `Box` to prevent text lines from becoming too long on very wide screens, improving readability.
    *   Refined the `Grid` layout for the profile section to better utilize space. `sm` breakpoint used for `DetailItem`s.
    *   `DetailItem` now handles "N/A" display more gracefully.
    *   Better loading/error/empty states.
    *   The `RelationshipMapper` grid item now has `lg` breakpoint specified for finer control on larger screens.
    *   Extracted tab content rendering into a helper function for clarity.
    *   Refresh button now uses `useIsFetching` for more accurate disabled state.

**To Test and Observe:**

*   **Relationship Mapper:** This is the biggest change. See how the new `layoutUtils.js` handles your "Derek Thorn" example. It should be less of a "hairball." Observe if the sector-based grouping helps.
*   **Overall Layout:** Check the `CharacterDetail` page on a wide screen. The main content (profile + tabs) should be centered with a max width, and the relationship map should sit to its right (if shown). The gap next to the sidebar should feel more integrated because the `AppLayout` logic for main content margin is now more precise.
*   **Readability:** Text in the profile section should be easier to read due to constrained line lengths.
*   **Node Appearance:** Nodes in the mapper should be a bit cleaner.

This is another significant step. The relationship mapper layout is inherently complex, and perfect results for all graph structures are hard to achieve without very sophisticated algorithms or manual tweaking tools (which are beyond scope here). However, this iteration aims for a marked improvement in its visual utility.