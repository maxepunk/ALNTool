# StoryForge Frontend UI/UX Specialist Bundle

This file contains all relevant frontend source code and project context for a UI/UX refinement pass. Please review and suggest improvements to the user experience, visual polish, accessibility, and overall design. Focus on:
- Consistency and clarity of navigation and layout
- Visual hierarchy and information density
- Accessibility (contrast, keyboard navigation, ARIA, etc.)
- Responsiveness and mobile usability
- Modern UI/UX best practices
- Usefulness specific to the context of each page and the needs of the designers/writers involved
- Any areas where the user journey can be improved or made more delightful

**You do NOT need to review or suggest changes to third-party library code.**

---

## Project Context: StoryForge PRD

--- FILE: StoryForge PR.txt ---
Okay, this is excellent! It's very common for PRDs to evolve as a project progresses and the understanding of the underlying data and needs becomes clearer. Incorporating the learnings from Phase 1 and the detailed status update is key.

Let's create a new, enhanced, and consolidated PRD. This version will:

1.  Use the **Notion Backend Structure from your latest document as the absolute source of truth.**
2.  Integrate the **learnings and current status** of the project.
3.  **Restore and refine the detail for future phases (2-5)** from our previous consolidated version, adapting them to the now-concrete Notion structure.
4.  Provide clear guidance on handling data that might not have explicit Notion properties, prioritizing parsing from existing fields before considering adding new ones.

---

**Revised & Consolidated Project Request Document: StoryForge - Immersive Narrative Design Hub**

**Document Version:** 2.0 (Post Phase 1 Implementation)
**Date:** May 11, 2025 (Reflecting current project status date)

**Document Purpose:** This document provides the comprehensive and unified specification for the StoryForge tool. It reflects the completion of Phase 1 and incorporates a definitive understanding of the existing "About Last Night" Notion workspace structure. It is intended for the coding assistant to guide the development of subsequent phases.

**1. Project Background: The "About Last Night" Experience**
*   **Game:** "About Last Night... an Immersive Crime Thriller" (Internal Codename: "Recovery State")
*   **Overview:** A 90-minute, in-person immersive experience for 5-35 players in a near-future Silicon Valley setting. It combines escape room puzzles, role-play, social deduction, and strategic trading.
*   **Premise:** Players awaken in a warehouse post-party, memories fragmented, with CEO Marcus Blackwood dead.
    *   **Act 1: Murder Mystery:** Players investigate Marcus's death, recover "elements" (including physical/digital items representing memories), and build theories.
    *   **Act 2: Memory Trading & Deeper Conspiracy:** Discovery of a "memory reader" (RFID-based) reveals certain elements (specifically those designated as "memories") as tradable commodities. Marcus's death is revealed as self-inflicted due to memory-altering drug experiments. A countdown begins as memories risk irreversible corruption.
*   **Player Choices/Endings:** Cooperate with "The Detective," sell memories to the "Black Market," or work to recover personal memories.
*   **Central Mechanics:** Element Recovery (including Memory recovery), Puzzle Solving, Role-Playing & Social Deduction, Strategic Trading (Act 2).

**2. Project Overview & Goals (StoryForge Tool)**
*   **Project Name:** StoryForge
*   **Tool Goal:** To develop a custom web-based front-end design tool that uses the existing "About Last Night" Notion workspace (as defined in Section 4) as its backend. StoryForge will provide a visually intuitive, interconnected, and role-optimized environment for designing, managing, and iterating on the immersive narrative experience.
*   **Primary Objectives:**
    *   **Visualize Connections:** Enable easy understanding of relationships between Characters, Timeline Events, Puzzles, and Elements (including specialized Memory-type Elements).
    *   **Streamline Workflows:** Offer dedicated views and tools tailored for different team roles (Narrative Designer, Writer, Puzzle Designer, Asset Manager).
    *   **Centralize & Enhance Data Access:** Provide a more structured and interactive way to access and modify data stored in Notion databases.
    *   **Facilitate Iteration & Scaling:** Support ongoing design changes, ensure narrative consistency, and manage the complexity of a growing narrative.
    *   **Support Design Process:** Address interdependencies, timeline management, act structure, physical prop management, and playtesting.

**3. Core Technology Stack**
*   **Backend Data Store:** **Existing Notion Workspace** (via Notion API). *This is a critical constraint. The structure defined in Section 4 is the target.*
*   **Frontend Framework:** React (as implemented).
*   **Visualization Libraries:** (e.g., React Flow, Vis.js, D3.js - to be selected for Phase 2+).
*   **State Management:** React Query (as implemented for API service layer).
*   **Styling:** Material UI with a dark theme (as implemented).
*   **Backend-for-Frontend (BFF) / Middleware:** Node.js with Express.js (as implemented). This BFF handles Notion API interactions, caching, complex data transformations, and secure API key management.

**4. Notion Backend Structure (Definitive Gold Standard)**

StoryForge **must** read from and write to the Notion workspace structured with the following 4 primary databases. Property names and types provided below are based on your latest document and successful Phase 1 integration.

**Important Note on "Memory-Specific" Fields within the Elements Database:**
The `Elements` database serves as a general store for all items, including those that function narratively as "Memories." Many memory-specific attributes (e.g., `Corruption Status`, `RFID Token ID`, `Value Indicator`) are not explicit, separate Notion properties in the current `Elements` database schema.
*   **Strategy for Handling:**
    1.  **Primary Source:** The `Description/Text` (Rich Text) property of an Element is the most likely place to find and store these granular details for memory-type Elements.
    2.  **StoryForge Responsibility (Read):** For Elements identified as memories (e.g., via `Basic Type` like "Memory Token Video", "Memory Token Physical", "Corrupted Memory RFID"), StoryForge's frontend or BFF will need to parse the `Description/Text` content to extract and display these memory-specific attributes.
    3.  **StoryForge Responsibility (Write):** When editing these memory-specific attributes in StoryForge, the tool will update the relevant structured information within the `Description/Text` field of the Notion page. This requires a consistent format (e.g., a specific markdown structure, key-value pairs, or a hidden JSON block within the Rich Text) that StoryForge can read and write.
    4.  **Adding New Notion Properties (Last Resort):** Only if parsing/embedding within `Description/Text` proves unmanageable or severely impacts performance for essential fields, should adding a new explicit property to the Notion `Elements` database be considered. This must be done carefully via the API to avoid redundancy and ensure consistency. *Example: If `Corruption Status` needs frequent, independent filtering at the Notion DB level and cannot be reliably parsed, it might become a candidate for a dedicated Select property.* Discuss with the team before making schema changes.

**(A) Characters Database**
*   **Notion DatabaseID:** `18c2f33d583f8060a6abde32ff06bca2`
*   **Based on:** `About Last Night…Characters_all.csv` and individual character MD files.
*   **Properties:**
    *   `Name` (Title - Primary Key)
    *   `Type` (Select: "Player", "NPC")
    *   `Tier` (Select: "Core", "Secondary", "Tertiary")
    *   `Character Logline` (Text)
    *   `Overview & Key Relationships` (Rich Text)
    *   `Emotion towards CEO & others` (Text)
    *   `Primary Action` (Text - Primary goal at the party)
    *   `Events` (Relation to `Timeline` DB - `Timeline.Description`)
    *   `Character Puzzles` (Relation to `Puzzles` DB - `Puzzles.Puzzle`)
    *   `Owned Elements` (Relation to `Elements` DB - `Elements.Name`)
    *   `Associated Elements` (Relation to `Elements` DB - `Elements.Name`)
    *   `Connections` (Number)
    *   *(Content from individual Character MD files like `Alex Character Sheet...md` is represented by an `Owned Element` of `Basic Type`: "Character Sheet". The `Description/Text` of that Element contains the sheet content.)*

**(B) Timeline Database (Events)**
*   **Notion DatabaseID:** `1b52f33d583f80deae5ad20020c120dd`
*   **Based on:** `About Last Night…Timeline.csv` and individual event MD files.
*   **Properties:**
    *   `Description` (Title - Primary Key, e.g., Event title)
    *   `Date` (Date)
    *   `Characters Involved` (Relation to `Characters` DB - `Characters.Name`)
    *   `Memory/Evidence` (Relation to `Elements` DB - `Elements.Name`)
    *   `mem type` (Text/Select - e.g., "Prop", "Set Dressing", "Memory Token Video")
    *   `Notes` (Rich Text)

**(C) Puzzles Database**
*   **Notion DatabaseID:** `1b62f33d583f80cc87cfd7d6c4b0b265`
*   **Based on:** `About Last Night…Puzzles_all.csv` and individual puzzle MD files.
*   **Properties:**
    *   `Puzzle` (Title - Primary Key, e.g., Puzzle name)
    *   `Owner` (Relation to `Characters` DB - `Characters.Name`)
    *   `Locked Item` (Relation to `Elements` DB - `Elements.Name`)
    *   `Puzzle Elements` (Relation to `Elements` DB - `Elements.Name`, i.e., elements required for the puzzle)
    *   `Rewards` (Relation to `Elements` DB - `Elements.Name`, i.e., elements rewarded by the puzzle)
    *   `Story Reveals` (Text or Relation to `Timeline` DB - `Timeline.Description`)
    *   `Timing` (Select, e.g., "Act 1", "Act 2")
    *   `Parent item` (Relation to self - `Puzzles.Puzzle`, for sub-puzzles)
    *   `Sub-Puzzles` (Relation to self, multiple - `Puzzles.Puzzle`, for parent puzzles listing sub-puzzles)
    *   `Asset Link` (URL, e.g., Canva links)
    *   `Description/Solution` (Rich Text)
    *   `Narrative Threads` (Multi-select Text or individual Text properties if preferred for Notion filtering)

**(D) Elements Database**
*   **Notion DatabaseID:** `18c2f33d583f802091bcd84c7dd94306`
*   **Based on:** `About Last Night…Elements_all.csv` and individual element MD files. This database includes props, clues, AND memory representations.
*   **Properties:**
    *   `Name` (Title - Primary Key)
    *   `Owner` (Relation to `Characters` DB - `Characters.Name`)
    *   `Basic Type` (Select - e.g., "Prop", "Set Dressing", "Memory Token Video", "Memory Token Audio", "Memory Token Physical", "Corrupted Memory RFID", "Character Sheet", "Document", "Digital File", "Clue", "Container")
    *   `Description/Text` (Rich Text - Sourced from MD bodies. **For memory-type Elements, this field will also contain structured data for memory-specific attributes like `Memory ID`, `Memory Title`, `Memory Type (Narrative)`, `Content (for text memories)`, `Corruption Status`, `RFID Token ID`, `Value Indicator`, `Puzzle Integration Type`, `Puzzle Notes` to be parsed/managed by StoryForge.**)
    *   `Container` (Relation to self - `Elements.Name`, i.e., this element is *inside* another element)
    *   `Contents` (Relation to self, multiple - `Elements.Name`, i.e., this element *is* a container and lists items inside)
    *   `Container Puzzle` (Relation to `Puzzles` DB - `Puzzles.Puzzle`)
    *   `Required For (Puzzle)` (Relation to `Puzzles` DB - `Puzzles.Puzzle`)
    *   `Rewarded by (Puzzle)` (Relation to `Puzzles` DB - `Puzzles.Puzzle`)
    *   `Timeline Event` (Relation to `Timeline` DB - `Timeline.Description`)
    *   `Associated Characters` (Relation to `Characters` DB - `Characters.Name`)
    *   `Narrative Threads` (Multi-select Text or individual Text properties)
    *   `First Available` (Select, e.g., "Act 0", "Act 1", "Act 2")
    *   `Status` (Select - e.g., "Ready for Playtest", "Done", "In development", "Idea/Placeholder", "Source Prop/print", "To Design", "To Build", "Needs Repair")
    *   `Files & media` (Files & Media - For images, audio files, video files directly uploaded to Notion)
    *   `Content Link` (URL - For links to external files like Canva, Google Docs, or video/audio hosting if not using `Files & media`)
    *   `Production/Puzzle Notes` (Text)

**5. Feature Breakdown & Development Phases**

**(CURRENT PROJECT STATUS SUMMARY - From your update)**
*   **Phase 1: Core Setup & Read-Only Views - COMPLETED**
    *   Backend (BFF) fully functional with read endpoints for all 4 DBs, property mapping, relation mapping, error handling.
    *   Frontend React app with Material UI, navigation, dashboard, reusable components, list and detail views for all 4 entity types.
    *   Human-readable related entity display (names, not IDs).
    *   API service layer with React Query.
    *   Filtering of Elements by `Basic Type` (e.g., for memories) is implemented.

**Upcoming Work & Phase Definitions:**

*   **Immediate Next Steps (Priority Order - from your status update, integrated into phases below where appropriate):**
    1.  *Enhance UI for Existing Views (Ongoing/Phase 2 Polish)*: Add filtering options to all list views, improve mobile responsiveness, add visual indicators for memory types.
    2.  *Begin Phase 2 Development.*
    3.  *Caching Improvements (Ongoing/Phase 2 Non-Functional)*: Implement more aggressive client-side caching, consider BFF-level caching, add refresh mechanisms.
    4.  *User Experience Refinements (Ongoing/Phase 2 Polish)*: Add loading states, improve UI error handling, consider user preferences.
*   **Technical Debt & Improvements (Ongoing - address throughout subsequent phases):**
    1.  *Testing:* Expand frontend test coverage, fix skipped integration tests, add E2E tests.
    2.  *Performance:* Optimize data fetching, consider client-side pagination for large datasets, add proper caching headers.
        *   Implemented advanced BFF-level caching for fully mapped/resolved entity objects (e.g., a character with all its related item names resolved) to significantly improve performance on detail views, especially those using the Relationship Mapper. This mitigates N+1 query issues when fetching related data.
    3.  *Code Organization:* Refactor mappers, standardize error handling, review imports.

*   **Phase 2: Adding Interactivity & Relationship Visualization**
    *   **Status:** NOT STARTED (Next major phase)
    *   **Goal:** Enhance views to show relationships as clickable links, build visual mappers, and improve overall interactivity of the read-only data.
    *   **Tasks:**
        *   **Clickable Relationships:**
            *   Ensure all displayed relations in detail views (e.g., a Character's "Owned Elements," an Element's "Associated Puzzle") are clickable links navigating directly to that related item's detail view in StoryForge.
        *   **Visual Relationship Mapper (Core Feature):**
            *   Design and implement a component (e.g., using React Flow, Vis.js) that can be used on detail pages (Character, Element, Puzzle, Timeline Event).
            *   For a selected entity, display a node graph of its direct 1st-degree relations (e.g., a Character and their directly linked Events, Puzzles, and Elements).
            *   Nodes should be clickable to navigate to the detail page of that related entity.
        *   **Timeline Weaver (Enhanced Visualization):**
            *   Display Timeline Events on a more interactive visual timeline (e.g., using a library like `vis-timeline` or similar).
            *   Events as cards showing `Description` (Title), `Date`. Ensure chronological display.
            *   Clicking an event card should clearly show more details (e.g., in a modal or side-pane) including linked `Characters Involved` and `Memory/Evidence` (Elements) as clickable links.
        *   **Element Explorer (Enhancements for Memories):**
            *   When viewing an Element of a memory `Basic Type`, clearly display the parsed memory-specific attributes (from `Description/Text`) like `Corruption Status`, `Value Indicator`, `RFID Token ID`.
            *   Add visual indicators for different memory `Basic Type`s in list views (e.g., icons, color-coding).
        *   **Filtering & Advanced Searching:**
            *   Implement robust filtering options on all list views (beyond just `Basic Type` for Elements). Allow filtering by multiple properties (e.g., Character `Tier` AND `Type`).
            *   Implement a global search or advanced search bar to find items across all databases.
        *   **UI/UX Polish:** Address items from "Enhance UI" and "User Experience Refinements" in "Immediate Next Steps."
    *   **Key Deliverables for Phase 2:**
        *   All relational links are fully navigable within StoryForge.
        *   Functional read-only visual relationship mapper for all core entities.
        *   Enhanced, interactive, chronological visual timeline.
        *   Clear display of parsed memory-specific data for relevant Elements.
        *   Advanced filtering implemented on all list views.
        *   Improved UI/UX based on immediate next steps.

**Milestone 1: Foundational Interactivity & Core UI Enhancements - COMPLETED**
*   **Implementation Summary:**
    *   Implemented React frontend with Material UI, navigation, dashboard, and reusable components.
    *   List and detail views for all 4 entity types (Characters, Timeline, Puzzles, Elements) with human-readable related entity display.
    *   Backend-for-Frontend (BFF) in Node.js/Express, with endpoints for all Notion databases, property mapping, and error handling.
    *   API service layer using React Query for data fetching and state management.
    *   Filtering of Elements by Basic Type implemented.
    *   Visual indicators (icons, color-coding) for memory types in Element list views.
    *   Loading states (skeletons/spinners) and improved UI error handling added.
    *   Initial frontend test coverage established for core components and layouts.

**Milestone 2: Advanced Filtering & Search Capabilities - COMPLETED**
*   **Implementation Summary:**
    *   All list views (Characters, Elements, Puzzles, Timeline) now support robust multi-property filtering via dropdowns/selects for relevant properties.
    *   Backend endpoints updated to accept multiple filter query params and build Notion filter objects using 'and'.
    *   Global search bar added to the AppBar, calling a new /search endpoint that searches by name/title across all 4 databases and displays grouped, clickable results in a modal.
    *   React Query hooks updated to support filter params.
    *   UI/UX polish: consistent filter UI, error handling, and loading states across all list views.

**Milestone 3: Caching Improvements - COMPLETED**
*   **Implementation Summary:**
    *   Client-side caching: All React Query hooks use a staleTime of 5 minutes and cacheTime of 10 minutes. Manual Refresh buttons added to all main list/detail pages to allow user-initiated refetching.
    *   Backend (BFF) caching: Implemented in-memory caching using node-cache for all Notion API responses (list and detail fetches for raw page/query data), with a 5-minute TTL. Cache hits/misses are logged for development.
    *   Manual cache clear endpoint: POST /api/cache/clear clears the in-memory cache and returns a success message.
    *   HTTP cache headers: All list and detail GET responses set Cache-Control: public, max-age=300 to enable browser/proxy caching.
    *   These improvements have significantly reduced Notion API calls and rate limiting during development and normal use.

**Milestone 4: Visual Relationship Mapper (Core Read-Only Feature) - COMPLETED**
*   **Objective:** Provide a graphical representation of direct relationships for any selected entity.
*   **Tasks:**
    *   Research & select visualization library (React Flow, Vis.js, D3.js, etc.).
    *   Design mapper component architecture.
    *   Implement read-only mapper (start with CharacterDetail, then extend to other entities).
    *   Ensure each node in the graph is clickable and navigates to the related entity's detail page.
*   **Implementation Summary:**
    *   Selected and integrated `@xyflow/react` (React Flow) as the visualization library.
    *   Developed the `RelationshipMapper.jsx` component, utilizing React Flow for graph rendering, including nodes, edges, background, controls, and minimap.
    *   The mapper component successfully displays the primary entity as a central node and its direct 1st-degree related entities as connected nodes.
    *   Implemented `transformDataToGraphElements` logic within the mapper to process `relationshipData` (fetched and mapped by the BFF) for Characters, Elements, Puzzles, and Timeline Events to generate graph nodes and edges.
    *   Ensured nodes in the graph are clickable, navigating to the correct detail page for the related entity (e.g., clicking an Element node on a Character's map navigates to that Element's detail page).
    *   Addressed initial JavaScript import errors and rendering issues related to the React Flow library integration.
    *   Significantly improved performance by implementing BFF-level caching for fully mapped/resolved entity objects (as detailed in "Technical Debt & Improvements" and Milestone 3 enhancements). This was crucial for the Relationship Mapper to perform efficiently with entities having many relations.
    *   Standardized frontend routing for Timeline views (from `/timeline` to `/timelines`) to ensure consistent navigation from the mapper and other parts of the application.
*   **Implementation Notes:**
    *   To support efficient data loading for the Relationship Mapper, BFF controllers (e.g., `getCharacterById`) now cache the fully resolved/mapped entity object. This means after an initial fetch, subsequent requests for the same entity (within the cache TTL) receive the complete data structure (including names of related items) directly from the BFF cache, avoiding repeated, expensive lookups of related entities from Notion.

*   **Phase 3: Implementing Editing Capabilities**
    *   **Status:** NOT STARTED
    *   **Goal:** Enable users to edit existing data and create new entries via StoryForge, with all changes accurately reflected back in the Notion workspace.
    *   **Tasks:**
        *   **BFF (Write Operations):**
            *   Implement robust functions to update Notion page properties for all 4 databases (all relevant property types: Text, Rich Text, Select, Multi-select, Date, URL, Relation, Files & Media).
            *   Implement functions to create new Notion pages in specified databases.
            *   Crucially, handle updating Rich Text fields where structured data (like memory-specific attributes) is embedded. This requires careful parsing and reconstruction of the `Description/Text` field content.
            *   Handle creation and updating of Notion relation properties correctly (linking/unlinking).
        *   **Character Architect (Editable):**
            *   Allow editing of all character fields.
            *   Implement UI for linking/unlinking existing Timeline Events, Puzzles, and Elements.
            *   Ability to create a new character (creates a new page in Notion `Characters` DB).
        *   **Element Explorer (Editable):**
            *   Allow editing of all general Element fields.
            *   **For memory-type Elements:** Provide UI to edit the parsed memory-specific attributes (e.g., `Corruption Status`, `RFID Token ID`, `Value Indicator`, `Memory Title`). These changes will be written back into the structured part of the `Description/Text` field in Notion.
            *   Implement UI to manage `Files & media` (uploading new files, removing existing ones).
            *   Manage `Container`/`Contents` relationships (linking elements as containers/contents).
            *   Link/unlink Narrative Threads, Puzzles, Timeline Events, Associated Characters.
            *   Ability to create a new element (creates a new page in Notion `Elements` DB).
        *   **Puzzle Forge (Editable):**
            *   Allow editing of all puzzle details.
            *   Link/unlink Elements (Required/Rewards/Locked Item) and other Puzzles (Parent/Sub).
            *   Ability to create a new puzzle.
        *   **Timeline Weaver (Editable):**
            *   Allow editing of event details.
            *   Link/unlink Characters and Elements (Memory/Evidence).
            *   Ability to create a new event on the timeline (creates Notion page).
            *   (Stretch Goal) Drag-and-drop to change event dates (updates Notion `Date` property).
    *   **Key Deliverables for Phase 3:**
        *   Users can comprehensively edit and create Characters, Elements (including their memory-specific attributes), Puzzles, and Timeline Events within StoryForge.
        *   All changes are accurately reflected in the Notion backend.
        *   Creation of new items and management of relationships is functional.

*   **Phase 4: Advanced Features & Role-Specific Dashboards**
    *   **Status:** NOT STARTED
    *   **Goal:** Implement more complex visualizations, workflow tools, and role-specific dashboards to further streamline the design process.
    *   **Tasks:**
        *   **Advanced Visual Relationship Mapper (Character Architect & potentially others):**
            *   Enhance the mapper from Phase 2 to be interactive. Allow creating/editing relationships (e.g., linking an Element to a Puzzle) directly on the graph, which then updates the Notion "Relation" properties.
        *   **Narrative Thread Tracker Module:**
            *   If `Narrative Threads` are primarily managed as Multi-select Text properties on items, create a view that aggregates all items tagged with specific threads.
            *   If a dedicated `Narrative Threads` database were to be created in Notion (out of scope for now but a future possibility), this module would manage it. For now, focus on viewing and filtering by existing `Narrative Threads` properties.
            *   Allow easy filtering by Narrative Threads across relevant modules (Characters, Puzzles, Elements, Events).
        *   **Role-Specific Dashboards (Initial Versions):**
            *   Design and implement dashboards tailored to:
                *   **Narrative Lead:** Focus on Timeline, Character Overviews, Element (Memory) status, and Narrative Thread progression.
                *   **Writer:** Focus on Character Profiles (especially `Overview & Key Relationships`, `Primary Action`), and Element `Description/Text` (for memory content, character sheets, documents).
                *   **Puzzle Designer:** Focus on Puzzle Forge, linked Elements (required, rewards, locked), and how Puzzles connect to Timeline Events or reveal Elements (Memories).
                *   **Asset Manager:** Focus on Element Hoard (`Basic Type`, `Fabrication Status`, `Files & media`, `Content Link`, `Container`/`Contents`).
        *   **Container Logic (Element Explorer - Enhanced):**
            *   Provide a more intuitive UI for viewing and managing items "inside" container Elements (e.g., a tree view or nested list within the container Element's detail page).
        *   **In-Game Tech Data Management (Enhanced UX):**
            *   Ensure fields like `RFID Token ID` (within Element `Description/Text`), links to media (`Files & media`, `Content Link`), are easily accessible and editable for relevant Element types.
    *   **Key Deliverables for Phase 4:**
        *   Interactive relationship mapping features.
        *   Effective tools for tracking and visualizing Narrative Threads.
        *   Initial versions of role-specific dashboards.
        *   Improved UI for container management.

*   **Phase 5: Refinements, Playtesting Support & Deployment**
    *   **Status:** NOT STARTED
    *   **Goal:** Polish UI/UX, add features to support playtesting, and prepare for robust team use and deployment.
    *   **Tasks:**
        *   **UI/UX Polish:** Comprehensive review and refinement of the entire application for usability, consistency, and aesthetics. Implement any remaining user preference settings (e.g., table densities).
        *   **Error Handling & Performance Optimization (Final Pass):**
            *   Ensure robust error handling for all API calls and user interactions, with clear feedback.
            *   Optimize client-side and BFF-side caching strategies thoroughly.
            *   Performance test with large datasets and optimize data fetching (e.g., server-side pagination if client-side proves insufficient, further optimization of React Query usage).
        *   **Playtesting Module (Basic):**
            *   Ability to "snapshot" or tag a version of the game design for a playtest (could be a simple tagging system on key Notion items, or a separate "Playtest Session" concept within StoryForge if a new Notion DB is added for this).
            *   Simple feedback forms linkable to Puzzles, Elements (Memories), Characters, or Timeline Events. Feedback submitted could:
                *   Create new pages in a dedicated "Playtest Feedback" Notion database, linked to the relevant game item.
                *   Alternatively, append feedback to a "Playtest Notes" Rich Text property on the item itself (simpler, less structured).
        *   **User Authentication (if needed beyond shared API key via BFF):** If distinct user actions, audit trails, or permissions within StoryForge become necessary.
        *   **Deployment:** Finalize deployment strategy for frontend and BFF to suitable hosting platforms (e.g., Vercel, Netlify for frontend; Heroku, Render, Fly.io for BFF). Setup CI/CD pipelines.
    *   **Key Deliverables for Phase 5:**
        *   A polished, performant, and stable version of StoryForge.
        *   Basic playtesting feedback collection mechanism integrated with Notion.
        *   Full deployment and operational readiness.
        *   Comprehensive documentation for users and maintainers.

**6. Non-Functional Requirements**
*   **Usability:** Intuitive for team members with varying technical skills.
*   **Performance:** Responsive for common tasks, considering Notion API limits. Aggressive caching and optimized API calls in BFF are crucial.
*   **Maintainability:** Well-structured, documented code (ongoing effort).
*   **Security:** Notion API key strictly handled in the BFF, not exposed client-side.
*   **Data Integrity:** Operations must accurately reflect in Notion and maintain relational integrity as defined by the Notion schema in Section 4. Changes to structured data within Rich Text fields must be handled carefully to preserve existing content.

**7. Assumptions & Dependencies**
*   **The Notion workspace structured precisely according to Section 4 is maintained.** Unauthorized changes to this Notion structure (e.g., renaming properties, changing types, deleting databases) outside of StoryForge's controlled modifications (like potentially adding a new property in a future, agreed-upon step) will break the tool.
*   Notion API remains stable, accessible, and its features support the required operations.
*   The initial data import from source CSVs and Markdown files has correctly established the baseline content and structure in Notion.

**8. Future Considerations (Out of Scope for current phases unless specified)**
*   Advanced branching narrative visualization beyond simple relationship mapping.
*   Real-time collaboration features within StoryForge itself (beyond Notion's).
*   More sophisticated version control or "snapshotting" of game states directly within StoryForge.
*   Direct export to game engine formats or other specialized playtest-ready documents.
*   Creation of a dedicated `Narrative Threads` Notion database and associated management features in StoryForge.
*   Creation of a dedicated `Playtest Feedback` Notion database.

**9. Step-by-Step Guidance for the Coding Assistant (Post Phase 1):**

1.  **Prioritize Phase 2:** Focus on the tasks outlined in Phase 2, particularly the visual relationship mapper, enhanced timeline, and fully clickable relationships.
2.  **Address Immediate Next Steps:** Integrate the "Enhance UI," "Caching Improvements," and "User Experience Refinements" items into your Phase 2 development work.
3.  **Tackle Technical Debt:** Allocate time throughout Phase 2 and subsequent phases to address the listed testing, performance, and code organization improvements.
4.  **Data Handling for Memories:** For displaying (Phase 2) and editing (Phase 3) memory-specific attributes within Elements, develop a robust strategy for parsing and updating the structured information within the `Description/Text` Rich Text field. Document the chosen format for this embedded data.
5.  **Notion API Interaction:** Continue to be mindful of API rate limits. Optimize data fetching. Ensure error handling for API calls is comprehensive and user-friendly.
6.  **Component Reusability:** Continue leveraging and expanding the library of reusable UI components.
7.  **State Management:** Utilize React Query effectively for server state, and ensure client state is managed efficiently.
8.  **Regular Check-ins:** Continue to communicate progress, discuss challenges (especially around Rich Text data management for memories), and ask questions.
9.  **Incremental Implementation:** Break down Phase 2 tasks into smaller, manageable sub-tasks.

---

This revised PRD should provide a solid and detailed roadmap for the continued development of StoryForge. The clarity on the Notion structure and the approach to handling memory-specific data within Elements are key improvements. Good luck with Phase 2!
---

## Relationship Mapper Component Documentation

--- FILE: storyforge/frontend/src/components/RelationshipMapper/README.md ---
# StoryForge - Immersive Narrative Design Hub

StoryForge is a custom web-based front-end design tool for the "About Last Night" immersive experience, providing a visually intuitive, interconnected, and role-optimized environment for designing, managing, and iterating on the narrative.

## Project Structure

This project consists of two main parts:

- **Backend (BFF):** A Node.js/Express server that securely interfaces with the Notion API
- **Frontend:** A React application that provides the user interface for the tool

## Quick Start

1. Set up the backend:
   ```bash
   cd backend
   npm install
   cp .env.example .env  # Then add your Notion API key
   npm run dev
   ```

2. Set up the frontend:
   ```bash
   cd frontend
   npm install
   npm run dev
   ```

3. Open your browser and navigate to:
   - Frontend: http://localhost:3000
   - Backend API: http://localhost:3001

## Features

StoryForge provides specialized views and tools for managing the four core elements of the "About Last Night" experience:

### Characters

View and manage characters, their relationships, and their connections to timeline events, puzzles, and elements.

### Timeline

Visualize and organize the chronological events of the narrative, with connections to characters and memories/evidence.

### Puzzles

Track puzzles, their requirements, rewards, and connections to the narrative.

### Elements

Manage physical props, set dressings, and memory tokens, with filtering capabilities to focus on specific types.

## Development Phases

This project is being developed in phases:

1. **Phase 1 (Current):** Core Setup & Read-Only Views
2. **Phase 2:** Adding Interactivity & Relationship Visualization
3. **Phase 3:** Implementing Editing Capabilities
4. **Phase 4:** Advanced Features & Role-Specific Dashboards
5. **Phase 5:** Refinements, Playtesting Support & Deployment

## Documentation

- [Backend Documentation](./backend/README.md)
- [Frontend Documentation](./frontend/README.md)
- [StoryForge PRD](../StoryForge%20PR.txt) - The original project requirements document 

---

## Main App Entry Points

--- FILE: storyforge/frontend/src/main.jsx ---
import React from 'react';
import ReactDOM from 'react-dom/client';
import { BrowserRouter } from 'react-router-dom';
import { QueryClient, QueryClientProvider } from 'react-query';
import CssBaseline from '@mui/material/CssBaseline';
import { ThemeProvider } from '@mui/material/styles';
import App from './App';
import theme from './theme';
import './index.css';
// Import React Flow styles globally
import '@xyflow/react/dist/style.css';

// Create a client for React Query
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      refetchOnWindowFocus: false,
      retry: 1,
    },
  },
});

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <BrowserRouter>
      <QueryClientProvider client={queryClient}>
        <ThemeProvider theme={theme}>
          <CssBaseline />
          <App />
        </ThemeProvider>
      </QueryClientProvider>
    </BrowserRouter>
  </React.StrictMode>,
); 
---

--- FILE: storyforge/frontend/src/App.jsx ---
import { useState, useEffect } from 'react';
import { Routes, Route, useLocation } from 'react-router-dom';
import { Box, Container, CircularProgress } from '@mui/material';
import { useQuery } from 'react-query';
import AppLayout from './layouts/AppLayout';
import Dashboard from './pages/Dashboard';
import Characters from './pages/Characters';
import CharacterDetail from './pages/CharacterDetail';
import Timeline from './pages/Timeline';
import TimelineDetail from './pages/TimelineDetail';
import Puzzles from './pages/Puzzles';
import PuzzleDetail from './pages/PuzzleDetail';
import Elements from './pages/Elements';
import ElementDetail from './pages/ElementDetail';
import NotFound from './pages/NotFound';
import { api } from './services/api';

function App() {
  const location = useLocation();
  const [isLoading, setIsLoading] = useState(true);
  
  // Fetch database metadata on app load
  const { data: metadata, isLoading: metadataLoading, error } = useQuery(
    'metadata',
    () => api.getDatabasesMetadata(),
    {
      retry: 3,
      onSettled: () => {
        // Set loading to false after metadata is fetched
        setIsLoading(false);
      },
    }
  );

  // If metadata fails to load, show error
  if (error && !isLoading) {
    return (
      <Container sx={{ 
        display: 'flex', 
        flexDirection: 'column',
        alignItems: 'center', 
        justifyContent: 'center',
        height: '100vh',
        textAlign: 'center',
        p: 4 
      }}>
        <h1>Connection Error</h1>
        <p>Could not connect to the StoryForge API. Please check that the backend server is running.</p>
        <p>Error: {error.message}</p>
      </Container>
    );
  }

  // Show loading spinner while initial metadata is being fetched
  if (isLoading) {
    return (
      <Box 
        sx={{ 
          display: 'flex', 
          justifyContent: 'center', 
          alignItems: 'center', 
          height: '100vh' 
        }}
      >
        <CircularProgress size={60} />
      </Box>
    );
  }

  return (
    <AppLayout>
      <Routes>
        <Route path="/" element={<Dashboard />} />
        
        {/* Characters routes */}
        <Route path="/characters" element={<Characters />} />
        <Route path="/characters/:id" element={<CharacterDetail />} />
        
        {/* Timeline routes */}
        <Route path="/timelines" element={<Timeline />} />
        <Route path="/timelines/:id" element={<TimelineDetail />} />
        
        {/* Puzzles routes */}
        <Route path="/puzzles" element={<Puzzles />} />
        <Route path="/puzzles/:id" element={<PuzzleDetail />} />
        
        {/* Elements routes */}
        <Route path="/elements" element={<Elements />} />
        <Route path="/elements/:id" element={<ElementDetail />} />
        
        {/* 404 route */}
        <Route path="*" element={<NotFound />} />
      </Routes>
    </AppLayout>
  );
}

export default App; 
---

--- FILE: storyforge/frontend/src/index.css ---
:root {
  font-family: 'Roboto', system-ui, Avenir, Helvetica, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;

  color-scheme: dark;
  color: rgba(255, 255, 255, 0.87);
  background-color: #121212;

  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  -webkit-text-size-adjust: 100%;
}

body {
  margin: 0;
  display: flex;
  min-width: 320px;
  min-height: 100vh;
}

#root {
  width: 100%;
  height: 100%;
}

a {
  color: #1e88e5;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* Custom scrollbar */
::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}

::-webkit-scrollbar-track {
  background: #1e1e1e;
}

::-webkit-scrollbar-thumb {
  background: #464646;
  border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
  background: #585858;
} 
---

--- FILE: storyforge/frontend/src/theme.js ---
import { createTheme } from '@mui/material/styles';

// Create a custom theme for StoryForge
const theme = createTheme({
  palette: {
    mode: 'dark',
    primary: {
      main: '#1e88e5', // blue
    },
    secondary: {
      main: '#ff5722', // deep orange
    },
    background: {
      default: '#121212',
      paper: '#1e1e1e',
    },
    success: {
      main: '#4caf50',
    },
    error: {
      main: '#f44336',
    },
    warning: {
      main: '#ff9800',
    },
    info: {
      main: '#2196f3',
    },
  },
  typography: {
    fontFamily: '"Roboto", "Helvetica", "Arial", sans-serif',
    h1: {
      fontSize: '2.5rem',
      fontWeight: 500,
    },
    h2: {
      fontSize: '2rem',
      fontWeight: 500,
    },
    h3: {
      fontSize: '1.75rem',
      fontWeight: 500,
    },
    h4: {
      fontSize: '1.5rem',
      fontWeight: 500,
    },
    h5: {
      fontSize: '1.25rem',
      fontWeight: 500,
    },
    h6: {
      fontSize: '1rem',
      fontWeight: 500,
    },
  },
  components: {
    MuiButton: {
      styleOverrides: {
        root: {
          textTransform: 'none',
        },
      },
    },
    MuiAppBar: {
      styleOverrides: {
        root: {
          boxShadow: 'none',
        },
      },
    },
    MuiDrawer: {
      styleOverrides: {
        paper: {
          backgroundColor: '#1e1e1e',
        },
      },
    },
  },
});

export default theme; 
---

## Layout

--- FILE: storyforge/frontend/src/layouts/AppLayout.jsx ---
import { useState } from 'react';
import { useNavigate, useLocation } from 'react-router-dom';
import {
  AppBar,
  Box,
  CssBaseline,
  Divider,
  Drawer,
  IconButton,
  List,
  ListItem,
  ListItemButton,
  ListItemIcon,
  ListItemText,
  Toolbar,
  Typography,
  useMediaQuery,
  Tooltip,
  Modal,
  TextField,
  List as MUIList,
  ListItem as MUIListItem,
  ListItemText as MUIListItemText,
  CircularProgress,
  InputAdornment,
} from '@mui/material';
import { useTheme } from '@mui/material/styles';
import MenuIcon from '@mui/icons-material/Menu';
import ChevronLeftIcon from '@mui/icons-material/ChevronLeft';
import DashboardIcon from '@mui/icons-material/Dashboard';
import PeopleIcon from '@mui/icons-material/People';
import TimelineIcon from '@mui/icons-material/Timeline';
import ExtensionIcon from '@mui/icons-material/Extension';
import InventoryIcon from '@mui/icons-material/Inventory';
import SearchIcon from '@mui/icons-material/Search';
import { api } from '../services/api';

const drawerWidth = 240;

const navItems = [
  { text: 'Dashboard', icon: <DashboardIcon />, path: '/' },
  { text: 'Characters', icon: <PeopleIcon />, path: '/characters' },
  { text: 'Timeline', icon: <TimelineIcon />, path: '/timelines' },
  { text: 'Puzzles', icon: <ExtensionIcon />, path: '/puzzles' },
  { text: 'Elements', icon: <InventoryIcon />, path: '/elements' },
];

export default function AppLayout({ children }) {
  const theme = useTheme();
  const isMobile = useMediaQuery(theme.breakpoints.down('md'));
  const [open, setOpen] = useState(!isMobile);
  const navigate = useNavigate();
  const location = useLocation();
  const [searchValue, setSearchValue] = useState('');
  const [searchOpen, setSearchOpen] = useState(false);
  const [searchResults, setSearchResults] = useState(null);
  const [searchLoading, setSearchLoading] = useState(false);
  const [searchError, setSearchError] = useState(null);

  const handleDrawerToggle = () => {
    setOpen(!open);
  };

  const handleNavigation = (path) => {
    navigate(path);
    if (isMobile) {
      setOpen(false);
    }
  };

  const handleSearchInputChange = (e) => setSearchValue(e.target.value);
  const handleSearchKeyDown = async (e) => {
    if (e.key === 'Enter' && searchValue.trim()) {
      setSearchLoading(true);
      setSearchError(null);
      setSearchResults(null);
      setSearchOpen(true);
      try {
        const results = await api.globalSearch(searchValue.trim());
        setSearchResults(results);
      } catch (err) {
        setSearchError('Error searching. Please try again.');
      } finally {
        setSearchLoading(false);
      }
    }
  };
  const handleSearchIconClick = async () => {
    if (searchValue.trim()) {
      setSearchLoading(true);
      setSearchError(null);
      setSearchResults(null);
      setSearchOpen(true);
      try {
        const results = await api.globalSearch(searchValue.trim());
        setSearchResults(results);
      } catch (err) {
        setSearchError('Error searching. Please try again.');
      } finally {
        setSearchLoading(false);
      }
    }
  };
  const handleCloseModal = () => {
    setSearchOpen(false);
    setSearchResults(null);
    setSearchError(null);
    setSearchLoading(false);
  };
  const handleResultClick = (type, id) => {
    let path = '';
    switch (type) {
      case 'characters': path = `/characters/${id}`; break;
      case 'timeline': path = `/timelines/${id}`; break;
      case 'puzzles': path = `/puzzles/${id}`; break;
      case 'elements': path = `/elements/${id}`; break;
      default: return;
    }
    navigate(path);
    handleCloseModal();
  };

  const drawer = (
    <div>
      <Toolbar sx={{ 
        display: 'flex', 
        alignItems: 'center', 
        justifyContent: 'space-between',
        px: [1],
      }}>
        <Typography variant="h6" component="div" sx={{ flexGrow: 1, fontWeight: 'bold' }}>
          StoryForge
        </Typography>
        {isMobile && (
          <IconButton onClick={handleDrawerToggle}>
            <ChevronLeftIcon />
          </IconButton>
        )}
      </Toolbar>
      <Divider />
      <List>
        {navItems.map((item) => (
          <ListItem key={item.text} disablePadding>
            <ListItemButton
              selected={location.pathname === item.path}
              onClick={() => handleNavigation(item.path)}
            >
              <ListItemIcon>{item.icon}</ListItemIcon>
              <ListItemText primary={item.text} />
            </ListItemButton>
          </ListItem>
        ))}
      </List>
    </div>
  );

  return (
    <Box sx={{ display: 'flex', height: '100vh' }}>
      <CssBaseline />
      <AppBar
        position="fixed"
        sx={{
          display: { md: open ? 'none' : 'flex' },
          width: { md: `calc(100% - ${open ? drawerWidth : 0}px)` },
          ml: { md: `${open ? drawerWidth : 0}px` },
          zIndex: (theme) => theme.zIndex.drawer + 1,
        }}
      >
        <Toolbar>
          <IconButton
            color="inherit"
            aria-label="open drawer"
            edge="start"
            onClick={handleDrawerToggle}
            sx={{ mr: 2 }}
          >
            <MenuIcon />
          </IconButton>
          <Typography variant="h6" noWrap component="div" sx={{ flexGrow: 1 }}>
            StoryForge
          </Typography>
          {/* Global Search Bar */}
          <TextField
            size="small"
            variant="outlined"
            placeholder="Search..."
            value={searchValue}
            onChange={handleSearchInputChange}
            onKeyDown={handleSearchKeyDown}
            sx={{ bgcolor: 'background.paper', borderRadius: 1, minWidth: 200 }}
            InputProps={{
              endAdornment: (
                <InputAdornment position="end">
                  <IconButton onClick={handleSearchIconClick} edge="end">
                    <SearchIcon />
                  </IconButton>
                </InputAdornment>
              ),
            }}
          />
        </Toolbar>
      </AppBar>
      <Box
        component="nav"
        sx={{ width: { md: open ? drawerWidth : 0 }, flexShrink: { md: 0 } }}
      >
        {/* Mobile drawer */}
        <Drawer
          variant="temporary"
          open={isMobile && open}
          onClose={handleDrawerToggle}
          ModalProps={{
            keepMounted: true, // Better mobile performance
          }}
          sx={{
            display: { xs: 'block', md: 'none' },
            '& .MuiDrawer-paper': { boxSizing: 'border-box', width: drawerWidth },
          }}
        >
          {drawer}
        </Drawer>
        {/* Desktop drawer */}
        <Drawer
          variant="persistent"
          sx={{
            display: { xs: 'none', md: 'block' },
            '& .MuiDrawer-paper': { boxSizing: 'border-box', width: drawerWidth },
          }}
          open={open}
        >
          {drawer}
        </Drawer>
      </Box>
      <Box
        component="main"
        sx={{
          flexGrow: 1,
          p: 3,
          width: { md: `calc(100% - ${open ? drawerWidth : 0}px)` },
          ml: { md: `${open ? drawerWidth : 0}px` },
          mt: { xs: '56px', sm: '64px' },
          height: 'calc(100vh - 64px)',
          overflow: 'auto',
        }}
      >
        {children}
      </Box>
      {/* Search Modal */}
      <Modal open={searchOpen} onClose={handleCloseModal}>
        <Box sx={{
          position: 'absolute',
          top: '50%',
          left: '50%',
          transform: 'translate(-50%, -50%)',
          width: 400,
          bgcolor: 'background.paper',
          borderRadius: 2,
          boxShadow: 24,
          p: 3,
          maxHeight: '80vh',
          overflowY: 'auto',
        }}>
          <Typography variant="h6" sx={{ mb: 2 }}>Search Results</Typography>
          {searchLoading && <Box sx={{ display: 'flex', justifyContent: 'center', my: 3 }}><CircularProgress /></Box>}
          {searchError && <Typography color="error">{searchError}</Typography>}
          {!searchLoading && !searchError && searchResults && Object.keys(searchResults).every(key => searchResults[key].length === 0) && (
            <Typography>No results found.</Typography>
          )}
          {!searchLoading && !searchError && searchResults && Object.entries(searchResults).map(([type, items]) => (
            items.length > 0 && (
              <Box key={type} sx={{ mb: 2 }}>
                <Typography variant="subtitle1" sx={{ fontWeight: 'bold', textTransform: 'capitalize' }}>{type}</Typography>
                <MUIList dense>
                  {items.map((item) => (
                    <MUIListItem button key={item.id} onClick={() => handleResultClick(type, item.id)}>
                      <MUIListItemText primary={item.name || item.puzzle || item.description} />
                    </MUIListItem>
                  ))}
                </MUIList>
              </Box>
            )
          ))}
        </Box>
      </Modal>
    </Box>
  );
} 
---

## API Service Layer

--- FILE: storyforge/frontend/src/services/api.js ---
import axios from 'axios';

// Create axios instance with base URL
const apiClient = axios.create({
  baseURL: '/api',
  headers: {
    'Content-Type': 'application/json',
  },
  timeout: 10000, // 10 seconds
});

// API endpoints
export const api = {
  // Metadata
  getDatabasesMetadata: async () => {
    const response = await apiClient.get('/metadata');
    return response.data;
  },

  // Characters
  getCharacters: async (filters = {}) => {
    const response = await apiClient.get('/characters', { params: filters });
    return response.data;
  },

  getCharacterById: async (id) => {
    const response = await apiClient.get(`/characters/${id}`);
    return response.data;
  },

  // Timeline
  getTimelineEvents: async (filters = {}) => {
    const response = await apiClient.get('/timeline', { params: filters });
    return response.data;
  },

  getTimelineEventById: async (id) => {
    const response = await apiClient.get(`/timeline/${id}`);
    return response.data;
  },

  // Puzzles
  getPuzzles: async (filters = {}) => {
    const response = await apiClient.get('/puzzles', { params: filters });
    return response.data;
  },

  getPuzzleById: async (id) => {
    const response = await apiClient.get(`/puzzles/${id}`);
    return response.data;
  },

  // Elements
  getElements: async (filters = {}) => {
    const response = await apiClient.get('/elements', { params: filters });
    return response.data;
  },

  getElementById: async (id) => {
    const response = await apiClient.get(`/elements/${id}`);
    return response.data;
  },

  // Global search
  globalSearch: async (query) => {
    const response = await apiClient.get('/search', { params: { q: query } });
    return response.data;
  },
};

// Error interceptor
apiClient.interceptors.response.use(
  (response) => response,
  (error) => {
    console.error('API Error:', error.response?.data || error.message);
    
    // Customize error handling here
    if (error.response?.status === 404) {
      console.log('Resource not found');
    }
    
    return Promise.reject(error);
  }
);

export default apiClient; 
---

## Reusable Components

--- FILE: storyforge/frontend/src/components/PageHeader.jsx ---
import React from 'react';
import { Box, Typography, Breadcrumbs, Link } from '@mui/material';
import { Link as RouterLink } from 'react-router-dom';
import NavigateNextIcon from '@mui/icons-material/NavigateNext';

/**
 * Reusable page header component with title and optional breadcrumbs
 * @param {Object} props Component props
 * @param {string} props.title Page title
 * @param {Array} props.breadcrumbs Optional breadcrumbs array of {name, path} objects
 * @param {React.ReactNode} props.action Optional action button/component
 */
function PageHeader({ title, breadcrumbs, action }) {
  return (
    <Box sx={{ mb: 4 }}>
      {/* Breadcrumbs */}
      {breadcrumbs && breadcrumbs.length > 0 && (
        <Breadcrumbs
          separator={<NavigateNextIcon fontSize="small" />}
          aria-label="breadcrumb"
          sx={{ mb: 1 }}
        >
          {breadcrumbs.map((crumb, index) => {
            const isLast = index === breadcrumbs.length - 1;
            
            return isLast ? (
              <Typography key={crumb.name} color="text.primary">
                {crumb.name}
              </Typography>
            ) : (
              <Link
                key={crumb.name}
                component={RouterLink}
                to={crumb.path}
                underline="hover"
                color="inherit"
              >
                {crumb.name}
              </Link>
            );
          })}
        </Breadcrumbs>
      )}
      
      {/* Title and action */}
      <Box sx={{ 
        display: 'flex', 
        justifyContent: 'space-between', 
        alignItems: 'center',
        flexWrap: 'wrap',
        gap: 2
      }}>
        <Typography variant="h4" component="h1">
          {title}
        </Typography>
        {action && (
          <Box sx={{ ml: 'auto' }}>
            {action}
          </Box>
        )}
      </Box>
    </Box>
  );
}

export default PageHeader; 
---

--- FILE: storyforge/frontend/src/components/DataTable.jsx ---
import { useState } from 'react';
import {
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  TablePagination,
  TableSortLabel,
  Paper,
  Box,
  CircularProgress,
  Typography,
  TextField,
  InputAdornment,
} from '@mui/material';
import SearchIcon from '@mui/icons-material/Search';

/**
 * Reusable data table component with sorting, pagination, and search
 * @param {Object} props - Component props
 * @param {Array} props.columns - Column definitions with {id, label, align, format, sortable}
 * @param {Array} props.data - Data array
 * @param {boolean} props.isLoading - Loading state
 * @param {string} props.emptyMessage - Message to display when data is empty
 * @param {Function} props.onRowClick - Function to call when a row is clicked
 */
function DataTable({ 
  columns, 
  data = [], 
  isLoading = false, 
  emptyMessage = 'No data to display',
  onRowClick,
  initialSortBy = '',
  initialSortDirection = 'asc',
  searchable = true
}) {
  // Pagination state
  const [page, setPage] = useState(0);
  const [rowsPerPage, setRowsPerPage] = useState(10);
  
  // Sorting state
  const [sortBy, setSortBy] = useState(initialSortBy);
  const [sortDirection, setSortDirection] = useState(initialSortDirection);
  
  // Search state
  const [searchQuery, setSearchQuery] = useState('');
  
  // Sort the data
  const sortedData = [...(data || [])].sort((a, b) => {
    if (!sortBy) return 0;
    
    const aValue = a[sortBy];
    const bValue = b[sortBy];
    
    if (aValue === bValue) return 0;
    if (aValue === null || aValue === undefined) return 1;
    if (bValue === null || bValue === undefined) return -1;
    
    const direction = sortDirection === 'asc' ? 1 : -1;
    
    if (typeof aValue === 'string') {
      return aValue.localeCompare(bValue) * direction;
    } else {
      return (aValue > bValue ? 1 : -1) * direction;
    }
  });
  
  // Filter the data by search query
  const filteredData = sortedData.filter(item => {
    if (!searchQuery) return true;
    const lowerQuery = searchQuery.toLowerCase();
    
    // Check each column that can be searched
    return columns.some(column => {
      const value = item[column.id];
      if (value === null || value === undefined) return false;
      return value.toString().toLowerCase().includes(lowerQuery);
    });
  });
  
  // Pagination handlers
  const handleChangePage = (event, newPage) => {
    setPage(newPage);
  };
  
  const handleChangeRowsPerPage = (event) => {
    setRowsPerPage(parseInt(event.target.value, 10));
    setPage(0);
  };
  
  // Sorting handlers
  const handleSortRequest = (property) => {
    const isAsc = sortBy === property && sortDirection === 'asc';
    setSortDirection(isAsc ? 'desc' : 'asc');
    setSortBy(property);
  };
  
  // Handle search input
  const handleSearchChange = (event) => {
    setSearchQuery(event.target.value);
    setPage(0); // Reset to first page when searching
  };
  
  // Get current page data
  const paginatedData = filteredData.slice(
    page * rowsPerPage,
    page * rowsPerPage + rowsPerPage
  );
  
  return (
    <Box>
      {/* Search input */}
      {searchable && (
        <Box sx={{ mb: 2 }}>
          <TextField
            fullWidth
            placeholder="Search..."
            variant="outlined"
            size="small"
            value={searchQuery}
            onChange={handleSearchChange}
            InputProps={{
              startAdornment: (
                <InputAdornment position="start">
                  <SearchIcon />
                </InputAdornment>
              ),
            }}
          />
        </Box>
      )}
      
      <Paper 
        sx={{ width: '100%', overflow: 'hidden', mb: 2 }}
        elevation={2}
      >
        <TableContainer sx={{ maxHeight: 600 }}>
          <Table stickyHeader aria-label="data table">
            <TableHead>
              <TableRow>
                {columns.map((column) => (
                  <TableCell
                    key={column.id}
                    align={column.align || 'left'}
                    sx={{ fontWeight: 'bold' }}
                  >
                    {column.sortable !== false ? (
                      <TableSortLabel
                        active={sortBy === column.id}
                        direction={sortBy === column.id ? sortDirection : 'asc'}
                        onClick={() => handleSortRequest(column.id)}
                      >
                        {column.label}
                      </TableSortLabel>
                    ) : (
                      column.label
                    )}
                  </TableCell>
                ))}
              </TableRow>
            </TableHead>
            <TableBody>
              {isLoading ? (
                <TableRow>
                  <TableCell colSpan={columns.length} align="center" sx={{ py: 3 }}>
                    <CircularProgress size={40} />
                  </TableCell>
                </TableRow>
              ) : paginatedData.length === 0 ? (
                <TableRow>
                  <TableCell colSpan={columns.length} align="center" sx={{ py: 3 }}>
                    <Typography color="text.secondary">
                      {searchQuery ? 'No results match your search.' : emptyMessage}
                    </Typography>
                  </TableCell>
                </TableRow>
              ) : (
                paginatedData.map((row, index) => (
                  <TableRow 
                    hover 
                    key={row.id || index}
                    onClick={onRowClick ? () => onRowClick(row) : undefined}
                    sx={{ cursor: onRowClick ? 'pointer' : 'default' }}
                  >
                    {columns.map((column) => (
                      <TableCell key={column.id} align={column.align || 'left'}>
                        {column.format ? column.format(row[column.id], row) : row[column.id]}
                      </TableCell>
                    ))}
                  </TableRow>
                ))
              )}
            </TableBody>
          </Table>
        </TableContainer>
        <TablePagination
          rowsPerPageOptions={[5, 10, 25, 50]}
          component="div"
          count={filteredData.length}
          rowsPerPage={rowsPerPage}
          page={page}
          onPageChange={handleChangePage}
          onRowsPerPageChange={handleChangeRowsPerPage}
        />
      </Paper>
    </Box>
  );
}

export default DataTable; 
---

### Relationship Mapper (Visualization)

--- FILE: storyforge/frontend/src/components/RelationshipMapper/RelationshipMapper.jsx ---
import { useState, useCallback, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import PropTypes from 'prop-types';
import {
  ReactFlow,
  Background, 
  Controls, 
  MiniMap,
  useNodesState,
  useEdgesState,
  MarkerType,
} from '@xyflow/react';
// Do not import style here as we're importing it globally in main.jsx
// import '@xyflow/react/dist/style.css';
import { 
  Box, 
  Typography, 
  Paper, 
  CircularProgress,
  Alert,
} from '@mui/material';

// Node types
import EntityNode from './EntityNode';
import FallbackGraph from './FallbackGraph';

// Layout algorithm
import { getLayoutedElements } from './layoutUtils';

const RelationshipMapper = ({ 
  title,
  entityType, 
  entityId, 
  entityName,
  relationshipData,
  isLoading,
  error
}) => {
  const navigate = useNavigate();
  const [nodes, setNodes, onNodesChange] = useNodesState([]);
  const [edges, setEdges, onEdgesChange] = useEdgesState([]);
  const [renderError, setRenderError] = useState(false);

  // Node types definition
  const nodeTypes = {
    entityNode: EntityNode,
  };

  // Add debug logging
  useEffect(() => {
    console.log('RelationshipMapper mounted', { entityType, entityId, entityName });
    if (relationshipData) {
      console.log('RelationshipData received', relationshipData);
    }
  }, [entityType, entityId, entityName, relationshipData]);

  // Transform data into nodes and edges when relationshipData changes
  useEffect(() => {
    if (!relationshipData || isLoading) return;
    
    try {
      console.log('Transforming data to graph elements');
      const { nodes: layoutedNodes, edges: layoutedEdges } = transformDataToGraphElements(
        entityType,
        entityId,
        entityName,
        relationshipData
      );
      
      console.log('Applying layout to nodes and edges', { nodeCount: layoutedNodes.length, edgeCount: layoutedEdges.length });
      // Apply automatic layout
      const { nodes: positionedNodes, edges: positionedEdges } = getLayoutedElements(
        layoutedNodes,
        layoutedEdges
      );
      
      console.log('Setting nodes and edges', { nodeCount: positionedNodes.length, edgeCount: positionedEdges.length });
      setNodes(positionedNodes);
      setEdges(positionedEdges);
      // Reset render error state if we successfully process the data
      setRenderError(false);
    } catch (err) {
      console.error('Error in RelationshipMapper:', err);
      setRenderError(true);
    }
  }, [relationshipData, entityType, entityId, entityName, isLoading, setNodes, setEdges]);

  // Handle node click to navigate to related entity
  const onNodeClick = useCallback((_, node) => {
    if (node.data?.route) {
      navigate(node.data.route);
    }
  }, [navigate]);

  // Handle errors in ReactFlow rendering
  const onError = useCallback((error) => {
    console.error('ReactFlow render error:', error);
    setRenderError(true);
  }, []);

  // Show loading state
  if (isLoading) {
    return (
      <Box sx={{ display: 'flex', justifyContent: 'center', p: 3 }}>
        <CircularProgress />
      </Box>
    );
  }

  // Show error state
  if (error) {
    return (
      <Box sx={{ p: 3 }}>
        <Alert severity="error">
          Error loading relationship data: {error.message}
        </Alert>
      </Box>
    );
  }

  // If no data available
  if (!relationshipData) {
    return (
      <Box sx={{ p: 3 }}>
        <Alert severity="info">
          No relationship data available to visualize.
        </Alert>
      </Box>
    );
  }

  // Use fallback renderer if we have render errors or no nodes
  if (renderError || (nodes.length <= 1 && edges.length === 0)) {
    return (
      <FallbackGraph 
        entityType={entityType}
        entityName={entityName}
        relationshipData={relationshipData}
      />
    );
  }

  return (
    <Paper sx={{ p: 2, height: '500px' }}>
      <Typography variant="h6" sx={{ mb: 2 }}>
        {title || 'Relationship Map'}
      </Typography>
      <Box sx={{ height: '90%', width: '100%' }}>
        <ReactFlow
          nodes={nodes}
          edges={edges}
          onNodesChange={onNodesChange}
          onEdgesChange={onEdgesChange}
          onNodeClick={onNodeClick}
          onError={onError}
          nodeTypes={nodeTypes}
          fitView
          fitViewOptions={{ padding: 0.2 }}
          minZoom={0.5}
          maxZoom={2}
          defaultViewport={{ x: 0, y: 0, zoom: 1 }}
        >
          <Background />
          <Controls />
          <MiniMap />
        </ReactFlow>
      </Box>
    </Paper>
  );
};

// Transform backend data into nodes and edges for ReactFlow
function transformDataToGraphElements(entityType, entityId, entityName, data) {
  // Create center node for current entity
  const centerNode = {
    id: entityId,
    position: { x: 0, y: 0 },
    type: 'entityNode',
    data: {
      label: entityName || 'Entity',
      type: entityType,
      id: entityId,
      isCenter: true,
    },
  };
  
  const nodes = [centerNode];
  const edges = [];
  
  // Helper to add related entity nodes and connections
  const addRelatedEntities = (relatedEntities, relationType, relationLabel, targetEntityType) => {
    if (!relatedEntities || !relatedEntities.length) return;
    
    relatedEntities.forEach((entity, index) => {
      // Skip if entity doesn't have an id
      if (!entity || !entity.id) {
        console.warn(`Missing entity id in ${targetEntityType} relation`);
        return;
      }
      
      // Create node for related entity
      const nodeId = `${targetEntityType}-${entity.id}`;
      nodes.push({
        id: nodeId,
        type: 'entityNode',
        data: {
          label: entity.name || entity.description || entity.puzzle || entity.id,
          type: targetEntityType,
          id: entity.id,
          route: `/${targetEntityType.toLowerCase()}s/${entity.id}`,
          properties: entity,
        },
        position: { x: 0, y: 0 }, // Position will be calculated by layout algorithm
      });
      
      // Create edge connecting the center entity to this related entity
      edges.push({
        id: `${entityId}-to-${nodeId}`,
        source: entityId,
        target: nodeId,
        label: relationLabel,
        type: 'default',
        markerEnd: {
          type: MarkerType.Arrow,
        },
        data: {
          relationType,
        },
      });
    });
  };
  
  // Add related entities based on entity type
  switch (entityType) {
    case 'Character':
      // Connect to elements owned
      addRelatedEntities(
        data.ownedElements,
        'owns',
        'Owns',
        'Element'
      );
      
      // Connect to associated elements
      addRelatedEntities(
        data.associatedElements,
        'associated_with',
        'Associated',
        'Element'
      );
      
      // Connect to events
      addRelatedEntities(
        data.events,
        'participates_in',
        'Participates',
        'Timeline'
      );
      
      // Connect to puzzles
      addRelatedEntities(
        data.puzzles,
        'involved_in',
        'Puzzles',
        'Puzzle'
      );
      break;
      
    case 'Element':
      // Connect to owner character
      if (data.owner) {
        addRelatedEntities(
          [data.owner],
          'owned_by',
          'Owned By',
          'Character'
        );
      }
      
      // Connect to associated characters
      addRelatedEntities(
        data.associatedCharacters,
        'associated_with',
        'Associated',
        'Character'
      );
      
      // Connect to timeline events
      addRelatedEntities(
        data.timelineEvents,
        'appears_in',
        'Appears In',
        'Timeline'
      );
      
      // Connect to required puzzles
      addRelatedEntities(
        data.requiredForPuzzle,
        'required_for',
        'Required For',
        'Puzzle'
      );
      
      // Connect to rewarded by puzzles
      addRelatedEntities(
        data.rewardedByPuzzle,
        'rewarded_by',
        'Rewarded By',
        'Puzzle'
      );
      
      // Connect to container puzzle
      addRelatedEntities(
        data.containerPuzzle ? [data.containerPuzzle] : [],
        'locked_by',
        'Locked By',
        'Puzzle'
      );
      
      // Connect to container (if this element is inside another)
      addRelatedEntities(
        data.container ? [data.container] : [],
        'inside',
        'Inside',
        'Element'
      );
      
      // Connect to contents (if this element contains others)
      addRelatedEntities(
        data.contents,
        'contains',
        'Contains',
        'Element'
      );
      break;
      
    case 'Puzzle':
      // Connect to owner character
      if (data.owner) {
        addRelatedEntities(
          [data.owner],
          'owned_by',
          'Owned By',
          'Character'
        );
      }
      
      // Connect to locked item
      if (data.lockedItem) {
        addRelatedEntities(
          [data.lockedItem],
          'locks',
          'Locks',
          'Element'
        );
      }
      
      // Connect to puzzle elements (required)
      addRelatedEntities(
        data.puzzleElements,
        'requires',
        'Requires',
        'Element'
      );
      
      // Connect to rewards
      addRelatedEntities(
        data.rewards,
        'rewards',
        'Rewards',
        'Element'
      );
      
      // Connect to parent puzzle
      addRelatedEntities(
        data.parentItem ? [data.parentItem] : [],
        'sub_of',
        'Sub of',
        'Puzzle'
      );
      
      // Connect to sub-puzzles
      addRelatedEntities(
        data.subPuzzles,
        'has_sub',
        'Has Sub',
        'Puzzle'
      );
      break;
      
    case 'Timeline':
      // Connect to characters involved
      addRelatedEntities(
        data.charactersInvolved,
        'involves',
        'Involves',
        'Character'
      );
      
      // Connect to memory/evidence elements
      addRelatedEntities(
        data.memoryEvidence,
        'evidenced_by',
        'Evidenced By',
        'Element'
      );
      break;
      
    default:
      break;
  }
  
  return { nodes, edges };
}

RelationshipMapper.propTypes = {
  title: PropTypes.string,
  entityType: PropTypes.oneOf(['Character', 'Element', 'Puzzle', 'Timeline']).isRequired,
  entityId: PropTypes.string.isRequired,
  entityName: PropTypes.string,
  relationshipData: PropTypes.object,
  isLoading: PropTypes.bool,
  error: PropTypes.object,
};

export default RelationshipMapper; 
---

--- FILE: storyforge/frontend/src/components/RelationshipMapper/EntityNode.jsx ---
import React, { memo, useEffect } from 'react';
import PropTypes from 'prop-types';
import { Handle, Position } from '@xyflow/react';
import { 
  Paper, 
  Typography, 
  Box,
  Chip,
} from '@mui/material';

// Icons for different entity types
import PersonIcon from '@mui/icons-material/Person';
import InventoryIcon from '@mui/icons-material/Inventory';
import EventIcon from '@mui/icons-material/Event';
import ExtensionIcon from '@mui/icons-material/Extension';

// Helper function to get color based on entity type
const getEntityColor = (type, isCenter = false) => {
  if (isCenter) return '#8364e2'; // Purple for center node
  
  switch (type) {
    case 'Character':
      return '#3f51b5'; // Indigo
    case 'Element':
      return '#4caf50'; // Green
    case 'Puzzle':
      return '#ff9800'; // Orange
    case 'Timeline':
      return '#e91e63'; // Pink
    default:
      return '#90a4ae'; // Blue Grey
  }
};

// Helper function to get icon based on entity type
const getEntityIcon = (type) => {
  switch (type) {
    case 'Character':
      return <PersonIcon fontSize="small" />;
    case 'Element':
      return <InventoryIcon fontSize="small" />;
    case 'Puzzle':
      return <ExtensionIcon fontSize="small" />;
    case 'Timeline':
      return <EventIcon fontSize="small" />;
    default:
      return null;
  }
};

const EntityNode = ({ data, isConnectable }) => {
  const { label, type, isCenter = false, properties } = data;
  const bgcolor = getEntityColor(type, isCenter);
  const icon = getEntityIcon(type);
  
  // Debug logging
  useEffect(() => {
    console.log('EntityNode rendering', { label, type, isCenter });
  }, [label, type, isCenter]);
  
  // Secondary information to display based on entity type
  const getSecondaryInfo = () => {
    if (!properties) return null;
    
    switch (type) {
      case 'Character':
        return properties.tier || properties.type;
      case 'Element':
        return properties.basicType;
      case 'Puzzle':
        return properties.timing;
      case 'Timeline':
        return properties.date ? new Date(properties.date).toLocaleDateString() : null;
      default:
        return null;
    }
  };
  
  const secondaryInfo = getSecondaryInfo();
  
  return (
    <Paper
      elevation={isCenter ? 6 : 3}
      sx={{
        padding: 1,
        borderRadius: 2,
        width: isCenter ? 180 : 150,
        height: 'auto',
        minHeight: 50,
        border: `2px solid ${bgcolor}`,
        backgroundColor: isCenter ? `${bgcolor}22` : 'background.paper', // Slight transparency for center node
        transition: 'all 0.2s ease',
        '&:hover': {
          transform: 'scale(1.05)',
          boxShadow: 6,
        },
        position: 'relative',
      }}
    >
      {/* Top handle */}
      <Handle
        type="target"
        position={Position.Top}
        isConnectable={isConnectable}
        style={{ background: bgcolor }}
      />
      
      {/* Entity information */}
      <Box sx={{ display: 'flex', flexDirection: 'column', alignItems: 'center' }}>
        <Box sx={{ display: 'flex', alignItems: 'center', mb: 0.5 }}>
          <Box sx={{ mr: 0.5, color: bgcolor }}>
            {icon}
          </Box>
          <Typography 
            variant="subtitle2" 
            sx={{ 
              fontWeight: isCenter ? 'bold' : 'medium',
              textAlign: 'center',
              overflow: 'hidden',
              textOverflow: 'ellipsis',
              whiteSpace: 'nowrap',
              width: '100%',
            }}
          >
            {label}
          </Typography>
        </Box>
        
        {secondaryInfo && (
          <Chip 
            label={secondaryInfo} 
            size="small" 
            sx={{ 
              backgroundColor: `${bgcolor}33`, // Very light 
              color: 'text.primary',
              fontSize: '0.65rem',
              height: 20,
              maxWidth: '90%',
              '& .MuiChip-label': {
                overflow: 'hidden',
                textOverflow: 'ellipsis',
                whiteSpace: 'nowrap',
              }
            }}
          />
        )}
      </Box>
      
      {/* Bottom handle */}
      <Handle
        type="source"
        position={Position.Bottom}
        isConnectable={isConnectable}
        style={{ background: bgcolor }}
      />
    </Paper>
  );
};

EntityNode.propTypes = {
  data: PropTypes.shape({
    label: PropTypes.string.isRequired,
    type: PropTypes.string.isRequired,
    isCenter: PropTypes.bool,
    properties: PropTypes.object,
  }).isRequired,
  isConnectable: PropTypes.bool,
};

export default memo(EntityNode); 
---

--- FILE: storyforge/frontend/src/components/RelationshipMapper/FallbackGraph.jsx ---
import React from 'react';
import PropTypes from 'prop-types';
import { Paper, Typography, Box, Alert } from '@mui/material';

/**
 * A simple fallback component that renders a basic representation of the relationship data
 * for debugging purposes when the main React Flow component fails
 */
const FallbackGraph = ({ entityType, entityName, relationshipData }) => {
  // Function to count relations
  const countRelations = () => {
    if (!relationshipData) return {};
    
    const counts = {};
    
    // Count based on entity type
    switch (entityType) {
      case 'Character':
        counts.ownedElements = relationshipData.ownedElements?.length || 0;
        counts.associatedElements = relationshipData.associatedElements?.length || 0;
        counts.events = relationshipData.events?.length || 0;
        counts.puzzles = relationshipData.puzzles?.length || 0;
        break;
        
      case 'Element':
        counts.owner = relationshipData.owner ? 1 : 0;
        counts.associatedCharacters = relationshipData.associatedCharacters?.length || 0;
        counts.timelineEvents = relationshipData.timelineEvents?.length || 0;
        counts.requiredFor = relationshipData.requiredFor?.length || 0;
        counts.rewardedBy = relationshipData.rewardedBy?.length || 0;
        counts.contents = relationshipData.contents?.length || 0;
        break;
        
      case 'Puzzle':
        counts.owner = relationshipData.owner ? 1 : 0;
        counts.lockedItem = relationshipData.lockedItem ? 1 : 0;
        counts.puzzleElements = relationshipData.puzzleElements?.length || 0;
        counts.rewards = relationshipData.rewards?.length || 0;
        counts.parentItem = relationshipData.parentItem ? 1 : 0;
        counts.subPuzzles = relationshipData.subPuzzles?.length || 0;
        break;
        
      case 'Timeline':
        counts.charactersInvolved = relationshipData.charactersInvolved?.length || 0;
        counts.memoryEvidence = relationshipData.memoryEvidence?.length || 0;
        break;
        
      default:
        break;
    }
    
    return counts;
  };
  
  const relationCounts = countRelations();
  
  return (
    <Paper sx={{ p: 2, height: '500px', overflow: 'auto' }}>
      <Alert severity="warning" sx={{ mb: 2 }}>
        Fallback renderer - React Flow visualization is not working
      </Alert>
      
      <Typography variant="h6" sx={{ mb: 2 }}>
        {entityName} Relationships (Fallback View)
      </Typography>
      
      <Box sx={{ mb: 2 }}>
        <Typography variant="subtitle2">Entity Type: {entityType}</Typography>
      </Box>
      
      <Typography variant="subtitle1" sx={{ mb: 1 }}>
        Relationship Counts:
      </Typography>
      
      <Box sx={{ pl: 2 }}>
        {Object.entries(relationCounts).map(([relationName, count]) => (
          <Typography key={relationName} variant="body2" sx={{ mb: 0.5 }}>
            • {relationName}: {count}
          </Typography>
        ))}
      </Box>
      
      {(!relationshipData || Object.keys(relationCounts).length === 0) && (
        <Alert severity="info" sx={{ mt: 2 }}>
          No relationship data available
        </Alert>
      )}
    </Paper>
  );
};

FallbackGraph.propTypes = {
  entityType: PropTypes.string.isRequired,
  entityName: PropTypes.string,
  relationshipData: PropTypes.object,
};

export default FallbackGraph; 
---

--- FILE: storyforge/frontend/src/components/RelationshipMapper/layoutUtils.js ---
/**
 * Layout utilities for arranging nodes in the relationship mapper
 */

// Radial layout - arranges nodes in a circle around the center node
export const getLayoutedElements = (nodes, edges, options = {}) => {
  console.log('getLayoutedElements called', { nodesCount: nodes?.length || 0, edgesCount: edges?.length || 0 });
  
  if (!nodes || nodes.length === 0) {
    console.warn('getLayoutedElements: No nodes to layout');
    return { nodes: nodes || [], edges: edges || [] };
  }
  
  try {
    // Find center node (usually the first node, which is the entity being viewed)
    const centerNode = nodes.find(node => node.data.isCenter) || nodes[0];
    console.log('Using center node:', centerNode.id);
    
    const centerPosition = { x: 0, y: 0 };
    
    // Set the center node's position
    centerNode.position = centerPosition;
    
    // Filter out the center node for arranging the rest
    const nodesToArrange = nodes.filter(node => node.id !== centerNode.id);
    console.log(`Nodes to arrange: ${nodesToArrange.length}`);
    
    if (nodesToArrange.length === 0) {
      console.log('No surrounding nodes to arrange');
      return { nodes, edges };
    }
    
    // Set default options
    const defaultOptions = {
      radius: 250, // Default radius for the circle
      startAngle: 0, // Starting angle in radians
      paddingFactor: 1.2, // Factor to increase spacing as nodes increase
    };
    
    const layoutOptions = { ...defaultOptions, ...options };
    
    // Group nodes by their type for better visualization
    const nodesByType = {};
    nodesToArrange.forEach(node => {
      const type = node.data.type;
      if (!nodesByType[type]) {
        nodesByType[type] = [];
      }
      nodesByType[type].push(node);
    });
    
    console.log('Nodes grouped by type:', Object.keys(nodesByType).map(type => 
      `${type}: ${nodesByType[type].length} nodes`
    ));
    
    // Calculate positions for each group
    let currentAngle = layoutOptions.startAngle;
    const typeCount = Object.keys(nodesByType).length;
    const angleStep = typeCount > 0 ? (2 * Math.PI) / typeCount : 0;
    
    Object.entries(nodesByType).forEach(([type, typeNodes]) => {
      // Each type gets its own segment in the circle
      const segmentCenter = currentAngle;
      const nodesInGroup = typeNodes.length;
      
      // Adjust segment size based on number of nodes
      const segmentSize = angleStep * 0.8; // Use 80% of the available angle space
      const nodeAngleStep = nodesInGroup > 1 ? segmentSize / (nodesInGroup - 1) : 0;
      
      // Starting angle for the first node in this group
      const startAngleForGroup = segmentCenter - (segmentSize / 2);
      
      console.log(`Positioning ${nodesInGroup} nodes of type ${type}`);
      
      // Position each node in the group
      typeNodes.forEach((node, index) => {
        const angle = startAngleForGroup + (index * nodeAngleStep);
        
        // Adjust radius based on the number of nodes in the group
        const adjustedRadius = layoutOptions.radius * 
                             (1 + (Math.min(nodesInGroup, 5) - 1) * 0.1);
        
        node.position = {
          x: centerPosition.x + adjustedRadius * Math.cos(angle),
          y: centerPosition.y + adjustedRadius * Math.sin(angle),
        };
      });
      
      // Move to the next segment
      currentAngle += angleStep;
    });
    
    console.log('Layout applied successfully');
    return { nodes, edges };
  } catch (error) {
    console.error('Error in getLayoutedElements:', error);
    return { nodes: nodes || [], edges: edges || [] };
  }
};

// Force-directed layout helper (more advanced, optional for future use)
export const getForceDirectedLayout = (nodes, edges, options = {}) => {
  // This would be a more complex force-directed layout algorithm
  // For now we're using the simpler radial layout above
  
  // Placeholder for future implementation
  return getLayoutedElements(nodes, edges, options);
}; 
---

## Pages

--- FILE: storyforge/frontend/src/pages/Dashboard.jsx ---
import { useQuery } from 'react-query';
import { Grid, Card, CardContent, CardHeader, Typography, Divider, Box, CircularProgress, CardActions, Button } from '@mui/material';
import { useNavigate } from 'react-router-dom';
import PeopleIcon from '@mui/icons-material/People';
import TimelineIcon from '@mui/icons-material/Timeline';
import ExtensionIcon from '@mui/icons-material/Extension';
import InventoryIcon from '@mui/icons-material/Inventory';
import MemoryIcon from '@mui/icons-material/Memory';
import PageHeader from '../components/PageHeader';
import { api } from '../services/api';
import { useEffect } from 'react';

function StatCard({ title, count, icon, color, onClick }) {
  return (
    <Card 
      sx={{ 
        height: '100%', 
        cursor: onClick ? 'pointer' : 'default',
        transition: 'transform 0.2s',
        '&:hover': onClick ? { transform: 'translateY(-4px)' } : {},
      }}
      onClick={onClick}
    >
      <CardContent sx={{ p: 3 }}>
        <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
          <Box 
            sx={{ 
              backgroundColor: `${color}.dark`,
              p: 1.5,
              borderRadius: 1,
              display: 'flex',
              mr: 2
            }}
          >
            {icon}
          </Box>
          <Typography variant="h6" color="text.secondary">
            {title}
          </Typography>
        </Box>
        <Typography variant="h3" component="div" sx={{ fontWeight: 'bold' }}>
          {count !== undefined ? count : <CircularProgress size={24} />}
        </Typography>
      </CardContent>
    </Card>
  );
}

function Dashboard() {
  const navigate = useNavigate();
  
  // Fetch character count
  const { data: characters } = useQuery('characters', api.getCharacters, {
    refetchOnWindowFocus: false,
  });
  
  // Fetch timeline events
  const { data: timelineEvents } = useQuery('timelineEvents', api.getTimelineEvents, {
    refetchOnWindowFocus: false,
  });
  
  // Fetch puzzles
  const { data: puzzles } = useQuery('puzzles', api.getPuzzles, {
    refetchOnWindowFocus: false,
  });
  
  // Fetch all elements
  const { data: elements } = useQuery('elements', () => api.getElements(), {
    refetchOnWindowFocus: false,
  });
  
  // Count memory elements
  const memoryCount = elements?.filter(el => 
    el.basicType === 'Memory Token Video' || 
    el.basicType?.includes('Memory')
  )?.length;
  
  // Add console log to debug white screen issue
  useEffect(() => {
    console.log('Dashboard component loaded');
  }, []);

  return (
    <div>
      <PageHeader 
        title="StoryForge Dashboard"
      />
      
      <Typography variant="subtitle1" sx={{ mb: 3 }}>
        Welcome to StoryForge, your immersive narrative design hub for "About Last Night".
      </Typography>
      
      <Grid container spacing={3}>
        {/* Stats cards */}
        <Grid item xs={12} sm={6} md={4}>
          <StatCard 
            title="Characters" 
            count={characters?.length} 
            icon={<PeopleIcon fontSize="large" sx={{ color: 'primary.contrastText' }} />}
            color="primary"
            onClick={() => navigate('/characters')}
          />
        </Grid>
        <Grid item xs={12} sm={6} md={4}>
          <StatCard 
            title="Timeline Events" 
            count={timelineEvents?.length}
            icon={<TimelineIcon fontSize="large" sx={{ color: 'secondary.contrastText' }} />}
            color="secondary"
            onClick={() => navigate('/timelines')}
          />
        </Grid>
        <Grid item xs={12} sm={6} md={4}>
          <StatCard 
            title="Puzzles" 
            count={puzzles?.length}
            icon={<ExtensionIcon fontSize="large" sx={{ color: 'success.contrastText' }} />}
            color="success"
            onClick={() => navigate('/puzzles')}
          />
        </Grid>
        <Grid item xs={12} sm={6} md={4}>
          <StatCard 
            title="Elements" 
            count={elements?.length}
            icon={<InventoryIcon fontSize="large" sx={{ color: 'info.contrastText' }} />}
            color="info"
            onClick={() => navigate('/elements')}
          />
        </Grid>
        <Grid item xs={12} sm={6} md={4}>
          <StatCard 
            title="Memories" 
            count={memoryCount}
            icon={<MemoryIcon fontSize="large" sx={{ color: 'warning.contrastText' }} />}
            color="warning"
            onClick={() => navigate('/elements?type=Memory Token Video')}
          />
        </Grid>
      </Grid>
    </div>
  );
}

export default Dashboard; 
---

--- FILE: storyforge/frontend/src/pages/Characters.jsx ---
import { useNavigate } from 'react-router-dom';
import { useQuery } from 'react-query';
import { Chip, Button, Typography, Paper, CircularProgress, Alert, Skeleton, FormControl, InputLabel, Select, MenuItem, Box } from '@mui/material';
import AddIcon from '@mui/icons-material/Add';
import RefreshIcon from '@mui/icons-material/Refresh';
import DataTable from '../components/DataTable';
import PageHeader from '../components/PageHeader';
import { api } from '../services/api';
import { useState } from 'react';

// Table column definitions
const columns = [
  { id: 'name', label: 'Name', sortable: true },
  { id: 'type', label: 'Type', sortable: true, 
    format: (value) => value ? (
      <Chip 
        size="small" 
        label={value} 
        color={value === 'Player' ? 'primary' : 'secondary'} 
      />
    ) : null
  },
  { id: 'tier', label: 'Tier', sortable: true,
    format: (value) => value ? (
      <Chip 
        size="small" 
        label={value} 
        color={
          value === 'Core' ? 'success' : 
          value === 'Secondary' ? 'info' : 
          'default'
        } 
      />
    ) : null
  },
  { id: 'logline', label: 'Character Logline', sortable: true },
  // Count of related items
  { id: 'ownedElements', label: 'Owned Items', sortable: true, 
    format: (value) => value?.length || 0
  },
  { id: 'events', label: 'Timeline Events', sortable: true, 
    format: (value) => value?.length || 0
  },
  { id: 'puzzles', label: 'Puzzles', sortable: true, 
    format: (value) => value?.length || 0 
  },
];

// Add filter options
const TYPE_OPTIONS = ['All Types', 'Player', 'NPC'];
const TIER_OPTIONS = ['All Tiers', 'Core', 'Secondary', 'Tertiary'];

function Characters() {
  const navigate = useNavigate();
  
  // State for filters
  const [type, setType] = useState('All Types');
  const [tier, setTier] = useState('All Tiers');
  // Build filters object
  const filters = {};
  if (type !== 'All Types') filters.type = type;
  if (tier !== 'All Tiers') filters.tier = tier;
  
  // Fetch characters data with all filters
  const { data: characters, isLoading, error, refetch } = useQuery(
    ['characters', filters],
    () => api.getCharacters(filters),
    { staleTime: 5 * 60 * 1000, cacheTime: 10 * 60 * 1000 }
  );
  
  // Handle row click to navigate to character details
  const handleRowClick = (row) => {
    navigate(`/characters/${row.id}`);
  };
  
  // Future feature: Add new character (Phase 3)
  const handleAddCharacter = () => {
    alert('This feature will be available in Phase 3 (Editing Capabilities)');
  };
  
  // Handle filter changes
  const handleTypeChange = (event) => setType(event.target.value);
  const handleTierChange = (event) => setTier(event.target.value);
  
  return (
    <div>
      <PageHeader 
        title="Characters" 
        action={
          <Box sx={{ display: 'flex', gap: 1 }}>
            <Button
              variant="outlined"
              startIcon={<RefreshIcon />}
              onClick={() => refetch()}
            >
              Refresh
            </Button>
            <Button 
              variant="contained" 
              startIcon={<AddIcon />}
              onClick={handleAddCharacter}
            >
              Add Character
            </Button>
          </Box>
        }
      />
      
      <Paper sx={{ p: 2, mb: 2 }}>
        <FormControl fullWidth sx={{ mb: 2 }}>
          <InputLabel id="character-type-label">Type</InputLabel>
          <Select
            labelId="character-type-label"
            id="character-type-select"
            value={type}
            label="Type"
            onChange={handleTypeChange}
          >
            {TYPE_OPTIONS.map((t) => (
              <MenuItem key={t} value={t}>{t}</MenuItem>
            ))}
          </Select>
        </FormControl>
        <FormControl fullWidth>
          <InputLabel id="character-tier-label">Tier</InputLabel>
          <Select
            labelId="character-tier-label"
            id="character-tier-select"
            value={tier}
            label="Tier"
            onChange={handleTierChange}
          >
            {TIER_OPTIONS.map((t) => (
              <MenuItem key={t} value={t}>{t}</MenuItem>
            ))}
          </Select>
        </FormControl>
      </Paper>
      
      {isLoading ? (
        <Skeleton variant="rectangular" height={400} sx={{ borderRadius: 2, mb: 2 }} />
      ) : (
        <DataTable 
          columns={columns}
          data={characters}
          isLoading={false}
          onRowClick={handleRowClick}
          initialSortBy="name"
          initialSortDirection="asc"
          emptyMessage={
            "No characters found in the database."
          }
        />
      )}
      
      {error && (
        <Alert severity="error" sx={{ mt: 2 }}>
          Error loading characters: {error.message}
        </Alert>
      )}
    </div>
  );
}

export default Characters; 
---

--- FILE: storyforge/frontend/src/pages/CharacterDetail.jsx ---
import { useState } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { useQuery } from 'react-query';
import {
  Box,
  Grid,
  Paper,
  Typography,
  Chip,
  Button,
  CircularProgress,
  Divider,
  List,
  ListItem,
  ListItemText,
  Alert,
  Tab,
  Tabs,
} from '@mui/material';
import ArrowBackIcon from '@mui/icons-material/ArrowBack';
import EditIcon from '@mui/icons-material/Edit';
import PageHeader from '../components/PageHeader';
import RelationshipMapper from '../components/RelationshipMapper';
import { api } from '../services/api';

function CharacterDetail() {
  const { id } = useParams();
  const navigate = useNavigate();
  const [activeTab, setActiveTab] = useState(0);
  const [showMapper, setShowMapper] = useState(true);
  
  // Fetch character data
  const { data: character, isLoading, error } = useQuery(
    ['character', id],
    () => api.getCharacterById(id),
    {
      enabled: !!id,
    }
  );
  
  // Handle tab change
  const handleTabChange = (event, newValue) => {
    setActiveTab(newValue);
  };
  
  // Go back to characters list
  const handleBack = () => {
    navigate('/characters');
  };
  
  // Future feature: Edit character (Phase 3)
  const handleEdit = () => {
    alert('This feature will be available in Phase 3 (Editing Capabilities)');
  };
  
  // Toggle relationship mapper visibility
  const toggleMapper = () => {
    setShowMapper(prev => !prev);
  };
  
  // Show loading state
  if (isLoading) {
    return (
      <Box sx={{ display: 'flex', justifyContent: 'center', p: 4 }}>
        <CircularProgress />
      </Box>
    );
  }
  
  // Show error state
  if (error) {
    return (
      <Box sx={{ p: 4 }}>
        <Alert severity="error">
          Error loading character: {error.message}
        </Alert>
        <Button
          startIcon={<ArrowBackIcon />}
          onClick={handleBack}
          sx={{ mt: 2 }}
        >
          Back to Characters
        </Button>
      </Box>
    );
  }
  
  // If character not found
  if (!character) {
    return (
      <Box sx={{ p: 4 }}>
        <Alert severity="warning">
          Character not found.
        </Alert>
        <Button
          startIcon={<ArrowBackIcon />}
          onClick={handleBack}
          sx={{ mt: 2 }}
        >
          Back to Characters
        </Button>
      </Box>
    );
  }
  
  return (
    <div>
      <PageHeader
        title={character.name}
        breadcrumbs={[
          { name: 'Characters', path: '/characters' },
          { name: character.name },
        ]}
        action={
          <Button
            variant="contained"
            startIcon={<EditIcon />}
            onClick={handleEdit}
          >
            Edit Character
          </Button>
        }
      />
      
      <Grid container spacing={3}>
        {/* Character overview */}
        <Grid item xs={12}>
          <Paper sx={{ p: 3 }}>
            <Grid container spacing={2}>
              <Grid item xs={12} md={6}>
                <Typography variant="subtitle2" color="text.secondary">
                  Type
                </Typography>
                <Box sx={{ mb: 2 }}>
                  {character.type && (
                    <Chip
                      label={character.type}
                      color={character.type === 'Player' ? 'primary' : 'secondary'}
                    />
                  )}
                </Box>
                
                <Typography variant="subtitle2" color="text.secondary">
                  Tier
                </Typography>
                <Box sx={{ mb: 2 }}>
                  {character.tier && (
                    <Chip
                      label={character.tier}
                      color={
                        character.tier === 'Core' ? 'success' : 
                        character.tier === 'Secondary' ? 'info' : 
                        'default'
                      }
                    />
                  )}
                </Box>
                
                <Typography variant="subtitle2" color="text.secondary">
                  Connections
                </Typography>
                <Typography variant="body1" sx={{ mb: 2 }}>
                  {character.connections !== null ? character.connections : 'None'}
                </Typography>
              </Grid>
              
              <Grid item xs={12} md={6}>
                <Typography variant="subtitle2" color="text.secondary">
                  Character Logline
                </Typography>
                <Typography variant="body1" sx={{ mb: 2 }}>
                  {character.logline || 'No logline provided.'}
                </Typography>
                
                <Typography variant="subtitle2" color="text.secondary">
                  Primary Action
                </Typography>
                <Typography variant="body1" sx={{ mb: 2 }}>
                  {character.primaryAction || 'No primary action provided.'}
                </Typography>
              </Grid>
            </Grid>
            
            {character.overview && (
              <>
                <Divider sx={{ my: 2 }} />
                <Typography variant="subtitle2" color="text.secondary">
                  Overview & Key Relationships
                </Typography>
                <Typography variant="body1">
                  {character.overview}
                </Typography>
              </>
            )}
            
            {character.emotion && (
              <>
                <Divider sx={{ my: 2 }} />
                <Typography variant="subtitle2" color="text.secondary">
                  Emotion towards CEO & others
                </Typography>
                <Typography variant="body1">
                  {character.emotion}
                </Typography>
              </>
            )}
          </Paper>
        </Grid>
        
        {/* Relationship Mapper */}
        <Grid item xs={12}>
          <Box sx={{ display: 'flex', justifyContent: 'flex-end', mb: 1 }}>
            <Button 
              variant="outlined" 
              onClick={toggleMapper}
              size="small"
            >
              {showMapper ? 'Hide' : 'Show'} Relationship Map
            </Button>
          </Box>
          
          {showMapper && (
            <RelationshipMapper
              title={`${character.name}'s Relationships`}
              entityType="Character"
              entityId={id}
              entityName={character.name}
              relationshipData={character}
              isLoading={isLoading}
              error={error}
            />
          )}
        </Grid>
        
        {/* Tabs for related content as lists */}
        <Grid item xs={12}>
          <Paper sx={{ p: 0 }}>
            <Tabs
              value={activeTab}
              onChange={handleTabChange}
              variant="fullWidth"
              indicatorColor="primary"
              textColor="primary"
            >
              <Tab label={`Owned Elements (${character.ownedElements?.length || 0})`} />
              <Tab label={`Associated Elements (${character.associatedElements?.length || 0})`} />
              <Tab label={`Timeline Events (${character.events?.length || 0})`} />
              <Tab label={`Puzzles (${character.puzzles?.length || 0})`} />
            </Tabs>
            
            <Box sx={{ p: 3 }}>
              {/* Owned Elements Tab */}
              {activeTab === 0 && (
                <>
                  {character.ownedElements?.length > 0 ? (
                    <List>
                      {character.ownedElements.map((el) => (
                        <ListItem 
                          key={el.id} 
                          button 
                          onClick={() => navigate(`/elements/${el.id}`)}
                        >
                          <ListItemText 
                            primary={el.name || el.id} 
                            secondary={`Element ID: ${el.id}`} 
                          />
                        </ListItem>
                      ))}
                    </List>
                  ) : (
                    <Typography color="text.secondary">
                      No owned elements found.
                    </Typography>
                  )}
                </>
              )}
              
              {/* Associated Elements Tab */}
              {activeTab === 1 && (
                <>
                  {character.associatedElements?.length > 0 ? (
                    <List>
                      {character.associatedElements.map((el) => (
                        <ListItem 
                          key={el.id} 
                          button 
                          onClick={() => navigate(`/elements/${el.id}`)}
                        >
                          <ListItemText 
                            primary={el.name || el.id} 
                            secondary={`Element ID: ${el.id}`} 
                          />
                        </ListItem>
                      ))}
                    </List>
                  ) : (
                    <Typography color="text.secondary">
                      No associated elements found.
                    </Typography>
                  )}
                </>
              )}
              
              {/* Timeline Events Tab */}
              {activeTab === 2 && (
                <>
                  {character.events?.length > 0 ? (
                    <List>
                      {character.events.map((ev) => (
                        <ListItem 
                          key={ev.id} 
                          button 
                          onClick={() => navigate(`/timeline/${ev.id}`)}
                        >
                          <ListItemText 
                            primary={ev.name || ev.id} 
                            secondary={`Timeline Event ID: ${ev.id}`} 
                          />
                        </ListItem>
                      ))}
                    </List>
                  ) : (
                    <Typography color="text.secondary">
                      No timeline events found.
                    </Typography>
                  )}
                </>
              )}
              
              {/* Puzzles Tab */}
              {activeTab === 3 && (
                <>
                  {character.puzzles?.length > 0 ? (
                    <List>
                      {character.puzzles.map((pz) => (
                        <ListItem 
                          key={pz.id} 
                          button 
                          onClick={() => navigate(`/puzzles/${pz.id}`)}
                        >
                          <ListItemText 
                            primary={pz.name || pz.id} 
                            secondary={`Puzzle ID: ${pz.id}`} 
                          />
                        </ListItem>
                      ))}
                    </List>
                  ) : (
                    <Typography color="text.secondary">
                      No puzzles found.
                    </Typography>
                  )}
                </>
              )}
            </Box>
          </Paper>
        </Grid>
      </Grid>
      
      {/* Back button */}
      <Box sx={{ mt: 4 }}>
        <Button
          startIcon={<ArrowBackIcon />}
          onClick={handleBack}
        >
          Back to Characters
        </Button>
      </Box>
    </div>
  );
}

export default CharacterDetail; 
---

--- FILE: storyforge/frontend/src/pages/Timeline.jsx ---
import { useNavigate } from 'react-router-dom';
import { useQuery } from 'react-query';
import { Chip, Typography, Paper, CircularProgress, Alert, FormControl, InputLabel, Select, MenuItem, Button } from '@mui/material';
import DataTable from '../components/DataTable';
import PageHeader from '../components/PageHeader';
import { api } from '../services/api';
import { useState } from 'react';
import RefreshIcon from '@mui/icons-material/Refresh';

// Table column definitions
const columns = [
  { id: 'description', label: 'Description', sortable: true },
  { id: 'date', label: 'Date', sortable: true },
  { id: 'charactersInvolved', label: 'Characters Involved', sortable: true,
    format: (value) => value?.length || 0
  },
];

// Add filter options
const MEM_TYPE_OPTIONS = ['All Types', 'Prop', 'Set Dressing', 'Memory Token Video', 'Memory Token Audio', 'Memory Token Physical', 'Corrupted Memory RFID'];

function Timeline() {
  const navigate = useNavigate();

  // State for filters
  const [memType, setMemType] = useState('All Types');
  // Build filters object
  const filters = {};
  if (memType !== 'All Types') filters.memType = memType;

  // Fetch timeline events data with all filters
  const { data: events, isLoading, error, refetch } = useQuery(
    ['timelineEvents', filters],
    () => api.getTimelineEvents(filters),
    { staleTime: 5 * 60 * 1000, cacheTime: 10 * 60 * 1000 }
  );

  // Handle row click to navigate to event details
  const handleRowClick = (row) => {
    navigate(`/timelines/${row.id}`);
  };

  // Handle filter change
  const handleMemTypeChange = (event) => setMemType(event.target.value);

  return (
    <div>
      <PageHeader 
        title="Timeline Events"
      />
      <Paper sx={{ p: 2, mb: 2, display: 'flex', alignItems: 'center', gap: 2 }}>
        <FormControl fullWidth>
          <InputLabel id="timeline-memtype-label">Memory/Evidence Type</InputLabel>
          <Select
            labelId="timeline-memtype-label"
            id="timeline-memtype-select"
            value={memType}
            label="Memory/Evidence Type"
            onChange={handleMemTypeChange}
          >
            {MEM_TYPE_OPTIONS.map((t) => (
              <MenuItem key={t} value={t}>{t}</MenuItem>
            ))}
          </Select>
        </FormControl>
        <Button
          variant="outlined"
          startIcon={<RefreshIcon />}
          onClick={() => refetch()}
        >
          Refresh
        </Button>
      </Paper>
      <Paper sx={{ p: 3 }}>
        <DataTable
          columns={columns}
          data={events}
          isLoading={isLoading}
          onRowClick={handleRowClick}
          initialSortBy="date"
          initialSortDirection="asc"
          emptyMessage="No timeline events found in the database."
        />
        {error && (
          <Alert severity="error" sx={{ mt: 2 }}>
            Error loading timeline events: {error.message}
          </Alert>
        )}
      </Paper>
    </div>
  );
}

export default Timeline; 
---

--- FILE: storyforge/frontend/src/pages/TimelineDetail.jsx ---
import { useState } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { useQuery } from 'react-query';
import {
  Box,
  Button,
  Chip,
  CircularProgress,
  Divider,
  Grid,
  List,
  ListItem,
  ListItemText,
  Paper,
  Tab,
  Tabs,
  Typography,
  Alert,
} from '@mui/material';
import ArrowBackIcon from '@mui/icons-material/ArrowBack';
import EditIcon from '@mui/icons-material/Edit';
import EventIcon from '@mui/icons-material/Event';
import PageHeader from '../components/PageHeader';
import RelationshipMapper from '../components/RelationshipMapper';
import { api } from '../services/api';

function TimelineDetail() {
  const { id } = useParams();
  const navigate = useNavigate();
  const [activeTab, setActiveTab] = useState(0);
  const [showMapper, setShowMapper] = useState(true);
  
  // Fetch timeline event data
  const { data: event, isLoading, error } = useQuery(
    ['timelineEvent', id],
    () => api.getTimelineEventById(id),
    {
      enabled: !!id,
    }
  );
  
  // Handler for tab changes
  const handleTabChange = (event, newValue) => {
    setActiveTab(newValue);
  };
  
  // Go back to timeline list
  const handleBack = () => {
    navigate('/timelines');
  };
  
  // Future feature: Edit timeline event (Phase 3)
  const handleEdit = () => {
    alert('This feature will be available in Phase 3 (Editing Capabilities)');
  };
  
  // Toggle relationship mapper visibility
  const toggleMapper = () => {
    setShowMapper(prev => !prev);
  };
  
  // Format date for display
  const formatDate = (dateString) => {
    if (!dateString) return 'No date provided';
    const date = new Date(dateString);
    return date.toLocaleDateString(undefined, { 
      year: 'numeric', 
      month: 'long', 
      day: 'numeric',
      hour: 'numeric',
      minute: 'numeric'
    });
  };
  
  // Show loading state
  if (isLoading) {
    return (
      <Box sx={{ display: 'flex', justifyContent: 'center', p: 4 }}>
        <CircularProgress />
      </Box>
    );
  }
  
  // Show error state
  if (error) {
    return (
      <Box sx={{ p: 4 }}>
        <Alert severity="error">
          Error loading timeline event: {error.message}
        </Alert>
        <Button startIcon={<ArrowBackIcon />} onClick={handleBack} sx={{ mt: 2 }}>
          Back to Timeline
        </Button>
      </Box>
    );
  }
  
  // If event not found
  if (!event) {
    return (
      <Box sx={{ p: 4 }}>
        <Alert severity="warning">
          Timeline event not found
        </Alert>
        <Button startIcon={<ArrowBackIcon />} onClick={handleBack} sx={{ mt: 2 }}>
          Back to Timeline
        </Button>
      </Box>
    );
  }
  
  return (
    <div>
      <PageHeader
        title={event.description}
        breadcrumbs={[
          { name: 'Timeline', path: '/timelines' },
          { name: event.description },
        ]}
        action={
          <Button
            variant="contained"
            startIcon={<EditIcon />}
            onClick={handleEdit}
          >
            Edit Event
          </Button>
        }
      />
      
      <Grid container spacing={3}>
        {/* Event overview */}
        <Grid item xs={12}>
          <Paper sx={{ p: 3 }}>
            <Grid container spacing={2}>
              <Grid item xs={12} md={6}>
                <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
                  <EventIcon sx={{ mr: 1, color: 'primary.main' }} />
                  <Typography variant="subtitle2" color="text.secondary">
                    Date & Time
                  </Typography>
                </Box>
                <Typography variant="body1" sx={{ ml: 4, mb: 3 }}>
                  {formatDate(event.date)}
                </Typography>
                
                {event.memType && (
                  <>
                    <Typography variant="subtitle2" color="text.secondary">
                      Memory Type
                    </Typography>
                    <Box sx={{ mb: 2 }}>
                      <Chip
                        label={event.memType}
                        color="secondary"
                        variant="outlined"
                        size="small"
                      />
                    </Box>
                  </>
                )}
              </Grid>
              
              <Grid item xs={12} md={6}>
                {/* Additional metadata could go here */}
              </Grid>
            </Grid>
            
            {event.notes && (
              <>
                <Divider sx={{ my: 2 }} />
                <Typography variant="subtitle2" color="text.secondary">
                  Notes
                </Typography>
                <Typography variant="body1" sx={{ whiteSpace: 'pre-wrap' }}>
                  {event.notes}
                </Typography>
              </>
            )}
          </Paper>
        </Grid>
        
        {/* Relationship Mapper */}
        <Grid item xs={12}>
          <Box sx={{ display: 'flex', justifyContent: 'flex-end', mb: 1 }}>
            <Button 
              variant="outlined" 
              onClick={toggleMapper}
              size="small"
            >
              {showMapper ? 'Hide' : 'Show'} Relationship Map
            </Button>
          </Box>
          
          {showMapper && (
            <RelationshipMapper
              title={`Event Relationships`}
              entityType="Timeline"
              entityId={id}
              entityName={event.description}
              relationshipData={event}
              isLoading={isLoading}
              error={error}
            />
          )}
        </Grid>
        
        {/* Tabs for related content */}
        <Grid item xs={12}>
          <Paper sx={{ p: 0 }}>
            <Tabs
              value={activeTab}
              onChange={handleTabChange}
              variant="fullWidth"
              indicatorColor="primary"
              textColor="primary"
            >
              <Tab label={`Characters Involved (${event.charactersInvolved?.length || 0})`} />
              <Tab label={`Memory/Evidence (${event.memoryEvidence?.length || 0})`} />
            </Tabs>
            
            <Box sx={{ p: 3 }}>
              {/* Characters Involved Tab */}
              {activeTab === 0 && (
                <>
                  {event.charactersInvolved?.length > 0 ? (
                    <List>
                      {event.charactersInvolved.map((character) => (
                        <ListItem 
                          key={character.id} 
                          button 
                          onClick={() => navigate(`/characters/${character.id}`)}
                        >
                          <ListItemText 
                            primary={character.name} 
                            secondary={character.tier ? `Tier: ${character.tier}` : null} 
                          />
                        </ListItem>
                      ))}
                    </List>
                  ) : (
                    <Typography color="text.secondary">
                      No characters are involved in this event.
                    </Typography>
                  )}
                </>
              )}
              
              {/* Memory/Evidence Tab */}
              {activeTab === 1 && (
                <>
                  {event.memoryEvidence?.length > 0 ? (
                    <List>
                      {event.memoryEvidence.map((element) => (
                        <ListItem 
                          key={element.id} 
                          button 
                          onClick={() => navigate(`/elements/${element.id}`)}
                        >
                          <ListItemText 
                            primary={element.name} 
                            secondary={element.basicType ? `Type: ${element.basicType}` : null} 
                          />
                        </ListItem>
                      ))}
                    </List>
                  ) : (
                    <Typography color="text.secondary">
                      No memory/evidence elements associated with this event.
                    </Typography>
                  )}
                </>
              )}
            </Box>
          </Paper>
        </Grid>
      </Grid>
      
      {/* Back button */}
      <Box sx={{ mt: 4 }}>
        <Button
          startIcon={<ArrowBackIcon />}
          onClick={handleBack}
        >
          Back to Timeline
        </Button>
      </Box>
    </div>
  );
}

export default TimelineDetail; 
---

--- FILE: storyforge/frontend/src/pages/Elements.jsx ---
import { useState } from 'react';
import { useNavigate, useLocation } from 'react-router-dom';
import { useQuery } from 'react-query';
import { Chip, Button, Box, Select, MenuItem, FormControl, InputLabel, Grid, Paper, Alert, Skeleton } from '@mui/material';
import AddIcon from '@mui/icons-material/Add';
import RefreshIcon from '@mui/icons-material/Refresh';
import DataTable from '../components/DataTable';
import PageHeader from '../components/PageHeader';
import { api } from '../services/api';

// Element types
const ELEMENT_TYPES = [
  'All Types',
  'Prop', 
  'Set Dressing', 
  'Memory Token Video', 
  'Character Sheet'
];

// Add filter options
const STATUS_OPTIONS = [
  'All Statuses',
  'Ready for Playtest',
  'Done',
  'In development',
  'Idea/Placeholder',
  'Source Prop/print',
  'To Design',
  'To Build',
  'Needs Repair',
];
const FIRST_AVAILABLE_OPTIONS = [
  'All Acts',
  'Act 0',
  'Act 1',
  'Act 2',
];

// Table column definitions
const columns = [
  { id: 'name', label: 'Name', sortable: true },
  { id: 'basicType', label: 'Type', sortable: true, 
    format: (value) => value ? (
      <Chip 
        size="small" 
        label={value} 
        color={
          value.includes('Memory') ? 'warning' : 
          value === 'Prop' ? 'info' : 
          value === 'Character Sheet' ? 'secondary' : 
          'default'
        }
        icon={value.includes('Memory') ? <span role="img" aria-label="memory">🧠</span> : undefined}
      />
    ) : null
  },
  { id: 'status', label: 'Status', sortable: true,
    format: (value) => value ? (
      <Chip 
        size="small" 
        label={value} 
        color={
          value === 'Ready for Playtest' || value === 'Done' ? 'success' : 
          value === 'In development' ? 'warning' : 
          value === 'Idea/Placeholder' ? 'info' : 
          'default'
        } 
      />
    ) : null
  },
  { id: 'firstAvailable', label: 'First Available', sortable: true },
  { id: 'description', label: 'Description', sortable: true },
  { id: 'owner', label: 'Owner', sortable: true, 
    format: (value) => value?.length ? `${value.length} Character(s)` : 'None'
  },
  { id: 'narrativeThreads', label: 'Narrative Threads', sortable: true, 
    format: (value) => value?.length ? (
      <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 0.5 }}>
        {value.map((thread, i) => (
          <Chip key={i} label={thread} size="small" variant="outlined" />
        ))}
      </Box>
    ) : 'None'
  },
];

function Elements() {
  const navigate = useNavigate();
  const location = useLocation();
  
  // Get type filter from URL query param
  const queryParams = new URLSearchParams(location.search);
  const typeFromQuery = queryParams.get('type');
  
  // State for element type filter
  const [elementType, setElementType] = useState(typeFromQuery || 'All Types');
  const [status, setStatus] = useState('All Statuses');
  const [firstAvailable, setFirstAvailable] = useState('All Acts');
  
  // Build filters object
  const filters = {};
  if (elementType !== 'All Types') filters.type = elementType;
  if (status !== 'All Statuses') filters.status = status;
  if (firstAvailable !== 'All Acts') filters.firstAvailable = firstAvailable;
  
  // Fetch elements data with all filters
  const { data: elements, isLoading, error, refetch } = useQuery(
    ['elements', filters],
    () => api.getElements(filters),
    { staleTime: 5 * 60 * 1000, cacheTime: 10 * 60 * 1000 }
  );
  
  // Handle row click to navigate to element details
  const handleRowClick = (row) => {
    navigate(`/elements/${row.id}`);
  };
  
  // Handle filter changes
  const handleTypeChange = (event) => {
    const newType = event.target.value;
    setElementType(newType);
    // Update URL query parameter for type only
    const params = new URLSearchParams();
    if (newType !== 'All Types') params.set('type', newType);
    navigate({ pathname: '/elements', search: params.toString() });
  };
  const handleStatusChange = (event) => setStatus(event.target.value);
  const handleFirstAvailableChange = (event) => setFirstAvailable(event.target.value);
  
  // Future feature: Add new element (Phase 3)
  const handleAddElement = () => {
    alert('This feature will be available in Phase 3 (Editing Capabilities)');
  };
  
  return (
    <div>
      <PageHeader 
        title="Elements & Memories" 
        action={
          <Box sx={{ display: 'flex', gap: 1 }}>
            <Button
              variant="outlined"
              startIcon={<RefreshIcon />}
              onClick={() => refetch()}
            >
              Refresh
            </Button>
            <Button 
              variant="contained" 
              startIcon={<AddIcon />}
              onClick={handleAddElement}
            >
              Add Element
            </Button>
          </Box>
        }
      />
      
      <Grid container spacing={2} sx={{ mb: 3 }}>
        <Grid item xs={12} md={4}>
          <Paper sx={{ p: 2, mb: 2 }}>
            <FormControl fullWidth sx={{ mb: 2 }}>
              <InputLabel id="element-type-label">Element Type</InputLabel>
              <Select
                labelId="element-type-label"
                id="element-type-select"
                value={elementType}
                label="Element Type"
                onChange={handleTypeChange}
              >
                {ELEMENT_TYPES.map((type) => (
                  <MenuItem key={type} value={type}>
                    {type}
                  </MenuItem>
                ))}
              </Select>
            </FormControl>
            <FormControl fullWidth sx={{ mb: 2 }}>
              <InputLabel id="element-status-label">Status</InputLabel>
              <Select
                labelId="element-status-label"
                id="element-status-select"
                value={status}
                label="Status"
                onChange={handleStatusChange}
              >
                {STATUS_OPTIONS.map((s) => (
                  <MenuItem key={s} value={s}>{s}</MenuItem>
                ))}
              </Select>
            </FormControl>
            <FormControl fullWidth>
              <InputLabel id="element-first-available-label">First Available</InputLabel>
              <Select
                labelId="element-first-available-label"
                id="element-first-available-select"
                value={firstAvailable}
                label="First Available"
                onChange={handleFirstAvailableChange}
              >
                {FIRST_AVAILABLE_OPTIONS.map((fa) => (
                  <MenuItem key={fa} value={fa}>{fa}</MenuItem>
                ))}
              </Select>
            </FormControl>
          </Paper>
        </Grid>
      </Grid>
      
      {isLoading ? (
        <Skeleton variant="rectangular" height={400} sx={{ borderRadius: 2, mb: 2 }} />
      ) : (
        <DataTable 
          columns={columns}
          data={elements}
          isLoading={false}
          onRowClick={handleRowClick}
          initialSortBy="name"
          initialSortDirection="asc"
          emptyMessage={
            elementType === 'All Types' 
              ? "No elements found in the database." 
              : `No ${elementType} elements found in the database.`
          }
        />
      )}
      
      {error && (
        <Alert severity="error" sx={{ mt: 2 }}>
          Error loading elements: {error.message}
        </Alert>
      )}
    </div>
  );
}

export default Elements; 
---

--- FILE: storyforge/frontend/src/pages/ElementDetail.jsx ---
import { useState } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { useQuery } from 'react-query';
import {
  Box,
  Button,
  Chip,
  CircularProgress,
  Divider,
  Grid,
  Link,
  List,
  ListItem,
  ListItemText,
  Paper,
  Tab,
  Tabs,
  Typography,
  Alert,
} from '@mui/material';
import ArrowBackIcon from '@mui/icons-material/ArrowBack';
import EditIcon from '@mui/icons-material/Edit';
import PageHeader from '../components/PageHeader';
import RelationshipMapper from '../components/RelationshipMapper';
import { api } from '../services/api';

function ElementDetail() {
  const { id } = useParams();
  const navigate = useNavigate();
  const [activeTab, setActiveTab] = useState(0);
  const [showMapper, setShowMapper] = useState(true);
  
  // Fetch element data
  const { data: element, isLoading, error } = useQuery(
    ['element', id],
    () => api.getElementById(id),
    {
      enabled: !!id,
    }
  );
  
  // Handler for tab changes
  const handleTabChange = (event, newValue) => {
    setActiveTab(newValue);
  };
  
  // Go back to elements list
  const handleBack = () => {
    navigate('/elements');
  };
  
  // Future feature: Edit element (Phase 3)
  const handleEdit = () => {
    alert('This feature will be available in Phase 3 (Editing Capabilities)');
  };
  
  // Toggle relationship mapper visibility
  const toggleMapper = () => {
    setShowMapper(prev => !prev);
  };
  
  // Show loading state
  if (isLoading) {
    return (
      <Box sx={{ display: 'flex', justifyContent: 'center', p: 4 }}>
        <CircularProgress />
      </Box>
    );
  }
  
  // Show error state
  if (error) {
    return (
      <Box sx={{ p: 4 }}>
        <Alert severity="error">
          Error loading element: {error.message}
        </Alert>
        <Button startIcon={<ArrowBackIcon />} onClick={handleBack} sx={{ mt: 2 }}>
          Back to Elements
        </Button>
      </Box>
    );
  }
  
  // If element not found
  if (!element) {
    return (
      <Box sx={{ p: 4 }}>
        <Alert severity="warning">
          Element not found
        </Alert>
        <Button startIcon={<ArrowBackIcon />} onClick={handleBack} sx={{ mt: 2 }}>
          Back to Elements
        </Button>
      </Box>
    );
  }

  // Helper to check if this is a memory-type element
  const isMemoryType = element.basicType?.includes('Memory') || 
                       element.basicType?.includes('Corrupted');
  
  return (
    <div>
      <PageHeader
        title={element.name}
        breadcrumbs={[
          { name: 'Elements', path: '/elements' },
          { name: element.name },
        ]}
        action={
          <Button
            variant="contained"
            startIcon={<EditIcon />}
            onClick={handleEdit}
          >
            Edit Element
          </Button>
        }
      />
      
      <Grid container spacing={3}>
        {/* Element overview */}
        <Grid item xs={12}>
          <Paper sx={{ p: 3 }}>
            <Grid container spacing={2}>
              <Grid item xs={12} md={6}>
                <Typography variant="subtitle2" color="text.secondary">
                  Basic Type
                </Typography>
                <Box sx={{ mb: 2 }}>
                  {element.basicType && (
                    <Chip
                      label={element.basicType}
                      color={
                        isMemoryType ? 'secondary' :
                        element.basicType === 'Prop' ? 'primary' :
                        element.basicType === 'Clue' ? 'success' :
                        'default'
                      }
                    />
                  )}
                </Box>
                
                <Typography variant="subtitle2" color="text.secondary">
                  Status
                </Typography>
                <Box sx={{ mb: 2 }}>
                  {element.status && (
                    <Chip
                      label={element.status}
                      color={
                        element.status === 'Ready for Playtest' ? 'success' :
                        element.status === 'Done' ? 'primary' :
                        element.status === 'In development' ? 'warning' :
                        element.status === 'Needs Repair' ? 'error' :
                        'default'
                      }
                    />
                  )}
                </Box>
                
                <Typography variant="subtitle2" color="text.secondary">
                  First Available
                </Typography>
                <Typography variant="body1" sx={{ mb: 2 }}>
                  {element.firstAvailable || 'Not specified'}
                </Typography>
              </Grid>
              
              <Grid item xs={12} md={6}>
                {element.owner && (
                  <>
                    <Typography variant="subtitle2" color="text.secondary">
                      Owner
                    </Typography>
                    <Typography 
                      variant="body1" 
                      sx={{ mb: 2, cursor: 'pointer', color: 'primary.main' }}
                      onClick={() => navigate(`/characters/${element.owner.id}`)}
                    >
                      {element.owner.name}
                    </Typography>
                  </>
                )}
                
                {element.contentLink && (
                  <>
                    <Typography variant="subtitle2" color="text.secondary">
                      Content Link
                    </Typography>
                    <Link 
                      href={element.contentLink} 
                      target="_blank" 
                      rel="noopener noreferrer"
                      sx={{ mb: 2, display: 'block' }}
                    >
                      External Content
                    </Link>
                  </>
                )}
                
                {isMemoryType && (
                  <>
                    <Typography variant="subtitle2" color="text.secondary" 
                      sx={{ color: 'secondary.main', fontWeight: 'bold' }}>
                      Memory Data
                    </Typography>
                    <Box sx={{ mb: 2, mt: 1 }}>
                      {/* This would be enhanced in future to parse and display specific memory attributes */}
                      <Typography variant="body2">
                        This is a memory-type element. Additional memory-specific data 
                        can be found in the description.
                      </Typography>
                    </Box>
                  </>
                )}
              </Grid>
            </Grid>
            
            {element.description && (
              <>
                <Divider sx={{ my: 2 }} />
                <Typography variant="subtitle2" color="text.secondary">
                  Description/Text
                </Typography>
                <Typography variant="body1" sx={{ whiteSpace: 'pre-wrap' }}>
                  {element.description}
                </Typography>
              </>
            )}
            
            {element.productionNotes && (
              <>
                <Divider sx={{ my: 2 }} />
                <Typography variant="subtitle2" color="text.secondary">
                  Production/Puzzle Notes
                </Typography>
                <Typography variant="body1">
                  {element.productionNotes}
                </Typography>
              </>
            )}
          </Paper>
        </Grid>
        
        {/* Relationship Mapper */}
        <Grid item xs={12}>
          <Box sx={{ display: 'flex', justifyContent: 'flex-end', mb: 1 }}>
            <Button 
              variant="outlined" 
              onClick={toggleMapper}
              size="small"
            >
              {showMapper ? 'Hide' : 'Show'} Relationship Map
            </Button>
          </Box>
          
          {showMapper && (
            <RelationshipMapper
              title={`${element.name} Relationships`}
              entityType="Element"
              entityId={id}
              entityName={element.name}
              relationshipData={element}
              isLoading={isLoading}
              error={error}
            />
          )}
        </Grid>
        
        {/* Tabs for related content */}
        <Grid item xs={12}>
          <Paper sx={{ p: 0 }}>
            <Tabs
              value={activeTab}
              onChange={handleTabChange}
              variant="scrollable"
              scrollButtons="auto"
              allowScrollButtonsMobile
              indicatorColor="primary"
              textColor="primary"
            >
              <Tab label="Associated Characters" />
              <Tab label="Timeline Events" />
              <Tab label="Required For Puzzles" />
              <Tab label="Rewarded By Puzzles" />
              {element.container && <Tab label="Container" />}
              {element.contents?.length > 0 && <Tab label="Contents" />}
            </Tabs>
            
            <Box sx={{ p: 3 }}>
              {/* Associated Characters Tab */}
              {activeTab === 0 && (
                <>
                  {element.associatedCharacters?.length > 0 ? (
                    <List>
                      {element.associatedCharacters.map((character) => (
                        <ListItem 
                          key={character.id} 
                          button 
                          onClick={() => navigate(`/characters/${character.id}`)}
                        >
                          <ListItemText 
                            primary={character.name} 
                            secondary={character.tier ? `Tier: ${character.tier}` : null} 
                          />
                        </ListItem>
                      ))}
                    </List>
                  ) : (
                    <Typography color="text.secondary">
                      No associated characters found.
                    </Typography>
                  )}
                </>
              )}
              
              {/* Timeline Events Tab */}
              {activeTab === 1 && (
                <>
                  {element.timelineEvents?.length > 0 ? (
                    <List>
                      {element.timelineEvents.map((event) => (
                        <ListItem 
                          key={event.id} 
                          button 
                          onClick={() => navigate(`/timeline/${event.id}`)}
                        >
                          <ListItemText 
                            primary={event.description} 
                            secondary={event.date ? new Date(event.date).toLocaleDateString() : null} 
                          />
                        </ListItem>
                      ))}
                    </List>
                  ) : (
                    <Typography color="text.secondary">
                      No timeline events found.
                    </Typography>
                  )}
                </>
              )}
              
              {/* Required For Puzzles Tab */}
              {activeTab === 2 && (
                <>
                  {element.requiredFor?.length > 0 ? (
                    <List>
                      {element.requiredFor.map((puzzle) => (
                        <ListItem 
                          key={puzzle.id} 
                          button 
                          onClick={() => navigate(`/puzzles/${puzzle.id}`)}
                        >
                          <ListItemText 
                            primary={puzzle.puzzle || puzzle.id} 
                            secondary={puzzle.timing ? `Timing: ${puzzle.timing}` : null} 
                          />
                        </ListItem>
                      ))}
                    </List>
                  ) : (
                    <Typography color="text.secondary">
                      This element is not required for any puzzles.
                    </Typography>
                  )}
                </>
              )}
              
              {/* Rewarded By Puzzles Tab */}
              {activeTab === 3 && (
                <>
                  {element.rewardedBy?.length > 0 ? (
                    <List>
                      {element.rewardedBy.map((puzzle) => (
                        <ListItem 
                          key={puzzle.id} 
                          button 
                          onClick={() => navigate(`/puzzles/${puzzle.id}`)}
                        >
                          <ListItemText 
                            primary={puzzle.puzzle || puzzle.id} 
                            secondary={puzzle.timing ? `Timing: ${puzzle.timing}` : null} 
                          />
                        </ListItem>
                      ))}
                    </List>
                  ) : (
                    <Typography color="text.secondary">
                      This element is not rewarded by any puzzles.
                    </Typography>
                  )}
                </>
              )}
              
              {/* Container Tab */}
              {element.container && activeTab === 4 && (
                <List>
                  <ListItem 
                    button 
                    onClick={() => navigate(`/elements/${element.container.id}`)}
                  >
                    <ListItemText 
                      primary={element.container.name} 
                      secondary={`Container: ${element.container.basicType || 'Unknown type'}`} 
                    />
                  </ListItem>
                </List>
              )}
              
              {/* Contents Tab */}
              {element.contents?.length > 0 && activeTab === (element.container ? 5 : 4) && (
                <List>
                  {element.contents.map((content) => (
                    <ListItem 
                      key={content.id} 
                      button 
                      onClick={() => navigate(`/elements/${content.id}`)}
                    >
                      <ListItemText 
                        primary={content.name} 
                        secondary={content.basicType ? `Type: ${content.basicType}` : null} 
                      />
                    </ListItem>
                  ))}
                </List>
              )}
            </Box>
          </Paper>
        </Grid>
      </Grid>
      
      {/* Back button */}
      <Box sx={{ mt: 4 }}>
        <Button
          startIcon={<ArrowBackIcon />}
          onClick={handleBack}
        >
          Back to Elements
        </Button>
      </Box>
    </div>
  );
}

export default ElementDetail; 
---

--- FILE: storyforge/frontend/src/pages/Puzzles.jsx ---
import { useNavigate } from 'react-router-dom';
import { useQuery } from 'react-query';
import { Chip, Typography, Paper, CircularProgress, Alert, Box, FormControl, InputLabel, Select, MenuItem, Button } from '@mui/material';
import DataTable from '../components/DataTable';
import PageHeader from '../components/PageHeader';
import { api } from '../services/api';
import { useState } from 'react';
import RefreshIcon from '@mui/icons-material/Refresh';

// Table column definitions
const columns = [
  { id: 'puzzle', label: 'Puzzle', sortable: true },
  { id: 'owner', label: 'Owner(s)', sortable: true, format: (value) => value?.length || 0 },
  { id: 'timing', label: 'Timing', sortable: true },
  { id: 'rewards', label: 'Rewards', sortable: true, format: (value) => value?.length || 0 },
  { id: 'narrativeThreads', label: 'Narrative Threads', sortable: true, format: (value) => value?.length ? (
    <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 0.5 }}>
      {value.map((thread, i) => (
        <Chip key={i} label={thread} size="small" variant="outlined" />
      ))}
    </Box>
  ) : 'None' },
];

// Add filter options
const TIMING_OPTIONS = ['All Timings', 'Act 1', 'Act 2'];

function Puzzles() {
  const navigate = useNavigate();

  // State for filters
  const [timing, setTiming] = useState('All Timings');
  // Build filters object
  const filters = {};
  if (timing !== 'All Timings') filters.timing = timing;

  // Fetch puzzles data with all filters
  const { data: puzzles, isLoading, error, refetch } = useQuery(
    ['puzzles', filters],
    () => api.getPuzzles(filters),
    { staleTime: 5 * 60 * 1000, cacheTime: 10 * 60 * 1000 }
  );

  // Handle row click to navigate to puzzle details
  const handleRowClick = (row) => {
    navigate(`/puzzles/${row.id}`);
  };

  // Handle filter change
  const handleTimingChange = (event) => setTiming(event.target.value);

  return (
    <div>
      <PageHeader 
        title="Puzzles"
      />
      <Paper sx={{ p: 2, mb: 2, display: 'flex', alignItems: 'center', gap: 2 }}>
        <FormControl fullWidth>
          <InputLabel id="puzzle-timing-label">Timing</InputLabel>
          <Select
            labelId="puzzle-timing-label"
            id="puzzle-timing-select"
            value={timing}
            label="Timing"
            onChange={handleTimingChange}
          >
            {TIMING_OPTIONS.map((t) => (
              <MenuItem key={t} value={t}>{t}</MenuItem>
            ))}
          </Select>
        </FormControl>
        <Button
          variant="outlined"
          startIcon={<RefreshIcon />}
          onClick={() => refetch()}
        >
          Refresh
        </Button>
      </Paper>
      <Paper sx={{ p: 3 }}>
        <DataTable
          columns={columns}
          data={puzzles}
          isLoading={isLoading}
          onRowClick={handleRowClick}
          initialSortBy="puzzle"
          initialSortDirection="asc"
          emptyMessage="No puzzles found in the database."
        />
        {error && (
          <Alert severity="error" sx={{ mt: 2 }}>
            Error loading puzzles: {error.message}
          </Alert>
        )}
      </Paper>
    </div>
  );
}

export default Puzzles; 
---

--- FILE: storyforge/frontend/src/pages/PuzzleDetail.jsx ---
import { useState } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { useQuery } from 'react-query';
import {
  Box,
  Button,
  Chip,
  CircularProgress,
  Divider,
  Grid,
  Link,
  List,
  ListItem,
  ListItemText,
  Paper,
  Tab,
  Tabs,
  Typography,
  Alert,
} from '@mui/material';
import ArrowBackIcon from '@mui/icons-material/ArrowBack';
import EditIcon from '@mui/icons-material/Edit';
import PageHeader from '../components/PageHeader';
import RelationshipMapper from '../components/RelationshipMapper';
import { api } from '../services/api';

function PuzzleDetail() {
  const { id } = useParams();
  const navigate = useNavigate();
  const [activeTab, setActiveTab] = useState(0);
  const [showMapper, setShowMapper] = useState(true);
  
  // Fetch puzzle data
  const { data: puzzle, isLoading, error } = useQuery(
    ['puzzle', id],
    () => api.getPuzzleById(id),
    {
      enabled: !!id,
    }
  );
  
  // Handler for tab changes
  const handleTabChange = (event, newValue) => {
    setActiveTab(newValue);
  };
  
  // Go back to puzzles list
  const handleBack = () => {
    navigate('/puzzles');
  };
  
  // Future feature: Edit puzzle (Phase 3)
  const handleEdit = () => {
    alert('This feature will be available in Phase 3 (Editing Capabilities)');
  };
  
  // Toggle relationship mapper visibility
  const toggleMapper = () => {
    setShowMapper(prev => !prev);
  };
  
  // Show loading state
  if (isLoading) {
    return (
      <Box sx={{ display: 'flex', justifyContent: 'center', p: 4 }}>
        <CircularProgress />
      </Box>
    );
  }
  
  // Show error state
  if (error) {
    return (
      <Box sx={{ p: 4 }}>
        <Alert severity="error">
          Error loading puzzle: {error.message}
        </Alert>
        <Button startIcon={<ArrowBackIcon />} onClick={handleBack} sx={{ mt: 2 }}>
          Back to Puzzles
        </Button>
      </Box>
    );
  }
  
  // If puzzle not found
  if (!puzzle) {
    return (
      <Box sx={{ p: 4 }}>
        <Alert severity="warning">
          Puzzle not found
        </Alert>
        <Button startIcon={<ArrowBackIcon />} onClick={handleBack} sx={{ mt: 2 }}>
          Back to Puzzles
        </Button>
      </Box>
    );
  }
  
  return (
    <div>
      <PageHeader
        title={puzzle.puzzle}
        breadcrumbs={[
          { name: 'Puzzles', path: '/puzzles' },
          { name: puzzle.puzzle },
        ]}
        action={
          <Button
            variant="contained"
            startIcon={<EditIcon />}
            onClick={handleEdit}
          >
            Edit Puzzle
          </Button>
        }
      />
      
      <Grid container spacing={3}>
        {/* Puzzle overview */}
        <Grid item xs={12}>
          <Paper sx={{ p: 3 }}>
            <Grid container spacing={2}>
              <Grid item xs={12} md={6}>
                <Typography variant="subtitle2" color="text.secondary">
                  Timing
                </Typography>
                <Box sx={{ mb: 2 }}>
                  {puzzle.timing && (
                    <Chip
                      label={puzzle.timing}
                      color={
                        puzzle.timing === 'Act 1' ? 'primary' :
                        puzzle.timing === 'Act 2' ? 'secondary' :
                        'default'
                      }
                    />
                  )}
                </Box>
                
                {puzzle.owner && (
                  <>
                    <Typography variant="subtitle2" color="text.secondary">
                      Owner
                    </Typography>
                    <Typography 
                      variant="body1" 
                      sx={{ mb: 2, cursor: 'pointer', color: 'primary.main' }}
                      onClick={() => navigate(`/characters/${puzzle.owner.id}`)}
                    >
                      {puzzle.owner.name}
                    </Typography>
                  </>
                )}
                
                {puzzle.narrativeThreads?.length > 0 && (
                  <>
                    <Typography variant="subtitle2" color="text.secondary">
                      Narrative Threads
                    </Typography>
                    <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 0.5, mb: 2 }}>
                      {puzzle.narrativeThreads.map((thread, index) => (
                        <Chip 
                          key={index} 
                          label={thread} 
                          size="small" 
                          variant="outlined" 
                        />
                      ))}
                    </Box>
                  </>
                )}
              </Grid>
              
              <Grid item xs={12} md={6}>
                {puzzle.assetLink && (
                  <>
                    <Typography variant="subtitle2" color="text.secondary">
                      Asset Link
                    </Typography>
                    <Link 
                      href={puzzle.assetLink} 
                      target="_blank" 
                      rel="noopener noreferrer"
                      sx={{ mb: 2, display: 'block' }}
                    >
                      External Asset
                    </Link>
                  </>
                )}
                
                {puzzle.storyReveals && (
                  <>
                    <Typography variant="subtitle2" color="text.secondary">
                      Story Reveals
                    </Typography>
                    <Typography variant="body1" sx={{ mb: 2 }}>
                      {puzzle.storyReveals}
                    </Typography>
                  </>
                )}
                
                {puzzle.parentItem && (
                  <>
                    <Typography variant="subtitle2" color="text.secondary">
                      Parent Puzzle
                    </Typography>
                    <Typography 
                      variant="body1" 
                      sx={{ mb: 2, cursor: 'pointer', color: 'primary.main' }}
                      onClick={() => navigate(`/puzzles/${puzzle.parentItem.id}`)}
                    >
                      {puzzle.parentItem.puzzle}
                    </Typography>
                  </>
                )}
              </Grid>
            </Grid>
            
            {puzzle.description && (
              <>
                <Divider sx={{ my: 2 }} />
                <Typography variant="subtitle2" color="text.secondary">
                  Description/Solution
                </Typography>
                <Typography variant="body1" sx={{ whiteSpace: 'pre-wrap' }}>
                  {puzzle.description}
                </Typography>
              </>
            )}
          </Paper>
        </Grid>
        
        {/* Relationship Mapper */}
        <Grid item xs={12}>
          <Box sx={{ display: 'flex', justifyContent: 'flex-end', mb: 1 }}>
            <Button 
              variant="outlined" 
              onClick={toggleMapper}
              size="small"
            >
              {showMapper ? 'Hide' : 'Show'} Relationship Map
            </Button>
          </Box>
          
          {showMapper && (
            <RelationshipMapper
              title={`${puzzle.puzzle} Relationships`}
              entityType="Puzzle"
              entityId={id}
              entityName={puzzle.puzzle}
              relationshipData={puzzle}
              isLoading={isLoading}
              error={error}
            />
          )}
        </Grid>
        
        {/* Tabs for related content */}
        <Grid item xs={12}>
          <Paper sx={{ p: 0 }}>
            <Tabs
              value={activeTab}
              onChange={handleTabChange}
              variant="scrollable"
              scrollButtons="auto"
              allowScrollButtonsMobile
              indicatorColor="primary"
              textColor="primary"
            >
              <Tab label="Required Elements" />
              <Tab label="Reward Elements" />
              {puzzle.lockedItem && <Tab label="Locked Item" />}
              {puzzle.subPuzzles?.length > 0 && <Tab label="Sub Puzzles" />}
            </Tabs>
            
            <Box sx={{ p: 3 }}>
              {/* Required Elements Tab */}
              {activeTab === 0 && (
                <>
                  {puzzle.puzzleElements?.length > 0 ? (
                    <List>
                      {puzzle.puzzleElements.map((element) => (
                        <ListItem 
                          key={element.id} 
                          button 
                          onClick={() => navigate(`/elements/${element.id}`)}
                        >
                          <ListItemText 
                            primary={element.name} 
                            secondary={element.basicType ? `Type: ${element.basicType}` : null} 
                          />
                        </ListItem>
                      ))}
                    </List>
                  ) : (
                    <Typography color="text.secondary">
                      No required elements found.
                    </Typography>
                  )}
                </>
              )}
              
              {/* Reward Elements Tab */}
              {activeTab === 1 && (
                <>
                  {puzzle.rewards?.length > 0 ? (
                    <List>
                      {puzzle.rewards.map((element) => (
                        <ListItem 
                          key={element.id} 
                          button 
                          onClick={() => navigate(`/elements/${element.id}`)}
                        >
                          <ListItemText 
                            primary={element.name} 
                            secondary={element.basicType ? `Type: ${element.basicType}` : null} 
                          />
                        </ListItem>
                      ))}
                    </List>
                  ) : (
                    <Typography color="text.secondary">
                      No reward elements found.
                    </Typography>
                  )}
                </>
              )}
              
              {/* Locked Item Tab */}
              {puzzle.lockedItem && activeTab === 2 && (
                <List>
                  <ListItem 
                    button 
                    onClick={() => navigate(`/elements/${puzzle.lockedItem.id}`)}
                  >
                    <ListItemText 
                      primary={puzzle.lockedItem.name} 
                      secondary={puzzle.lockedItem.basicType ? `Type: ${puzzle.lockedItem.basicType}` : null} 
                    />
                  </ListItem>
                </List>
              )}
              
              {/* Sub Puzzles Tab */}
              {puzzle.subPuzzles?.length > 0 && activeTab === (puzzle.lockedItem ? 3 : 2) && (
                <List>
                  {puzzle.subPuzzles.map((subPuzzle) => (
                    <ListItem 
                      key={subPuzzle.id} 
                      button 
                      onClick={() => navigate(`/puzzles/${subPuzzle.id}`)}
                    >
                      <ListItemText 
                        primary={subPuzzle.puzzle} 
                        secondary={subPuzzle.timing ? `Timing: ${subPuzzle.timing}` : null} 
                      />
                    </ListItem>
                  ))}
                </List>
              )}
            </Box>
          </Paper>
        </Grid>
      </Grid>
      
      {/* Back button */}
      <Box sx={{ mt: 4 }}>
        <Button
          startIcon={<ArrowBackIcon />}
          onClick={handleBack}
        >
          Back to Puzzles
        </Button>
      </Box>
    </div>
  );
}

export default PuzzleDetail; 
---

--- FILE: storyforge/frontend/src/pages/NotFound.jsx ---
import { Box, Typography, Button } from '@mui/material';
import { Link } from 'react-router-dom';

function NotFound() {
  return (
    <Box
      sx={{
        display: 'flex',
        flexDirection: 'column',
        alignItems: 'center',
        justifyContent: 'center',
        height: '100%',
        textAlign: 'center',
        p: 4,
      }}
    >
      <Typography variant="h1" component="h1" sx={{ fontSize: '8rem', fontWeight: 'bold', mb: 2 }}>
        404
      </Typography>
      <Typography variant="h4" component="h2" sx={{ mb: 4 }}>
        Page Not Found
      </Typography>
      <Typography variant="body1" sx={{ mb: 4 }}>
        The page you're looking for doesn't exist or has been moved.
      </Typography>
      <Button component={Link} to="/" variant="contained" color="primary">
        Return to Dashboard
      </Button>
    </Box>
  );
}

export default NotFound; 
---

// End of bundle. Please see above for all relevant context and code for your UI/UX review. 